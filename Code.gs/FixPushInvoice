function pushInvoiceToQBO(sheet) {
  checkRateLimit();  // üõ° Prevent hitting API rate limits

  try {
    Logger.log("üìå Starting invoice sync for sheet: " + sheet.getName());

    // ‚úÖ Extract invoice details from the sheet
    var invoiceNumber = sheet.getRange("A1").getValue().replace("Invoice Number: ", "").trim();
    var txnDate = sheet.getRange("A2").getValue().replace("Date: ", "").trim();
    var customer = sheet.getRange("A3").getValue().replace("Customer: ", "").trim();
    var total = parseFloat(sheet.getRange("A4").getValue().replace("Total: $", "").trim());

    Logger.log("üìÜ Transaction Date: " + txnDate);
    Logger.log("üë§ Customer Name: " + customer);
    Logger.log("üí∞ Invoice Total: " + total);

    // ‚úÖ Check if the invoice already exists in QuickBooks
    var invoiceId = getInvoiceIdByDocNumber(invoiceNumber);
    if (!invoiceId) {
      Logger.log("‚ùå Invoice not found. Creating a new invoice.");
      createInvoiceInQBO(sheet);
      return;
    }

    // ‚úÖ Fetch SyncToken for the existing invoice
    var syncTokens = getAllSyncTokens([invoiceId]);
    var syncToken = syncTokens[invoiceId] || "0";  // Use default "0" if missing

    // ‚úÖ Prepare the invoice data for update
    var invoiceData = {
      "Id": invoiceId,
      "SyncToken": syncToken,
      "DocNumber": invoiceNumber,
      "TxnDate": txnDate,
      "CustomerRef": { "name": customer },
      "TotalAmt": 0,  // Will be calculated dynamically
      "Line": []
    };

    Logger.log("üîÑ Collecting line items for invoice...");

    // ‚úÖ Read line items from the sheet
    var lastRow = sheet.getLastRow();
    var calculatedTotal = 0;

    for (var row = 7; row <= lastRow; row++) {
      var salesDescription = sheet.getRange("A" + row).getValue().trim(); // Previously itemName
      var qty = parseFloat(sheet.getRange("B" + row).getValue());
      var rate = parseFloat(sheet.getRange("C" + row).getValue());
      var amount = parseFloat(sheet.getRange("D" + row).getValue());
      var sku = sheet.getRange("E" + row).getValue(); // Previously itemRef

      // ‚úÖ Add line item if all fields are valid
      if (salesDescription && qty && rate && amount && sku) {
        Logger.log(`üõí Sales Description: ${salesDescription} | Qty: ${qty} | Rate: ${rate} | Amount: ${amount} | SKU: ${sku}`);

        invoiceData.Line.push({
          "DetailType": "SalesItemLineDetail",
          "Amount": amount,
          "Description": sku,  // Set SKU in the description field
          "SalesItemLineDetail": {
            "ItemRef": { "value": String(sku) }, // Keep SKU in the item reference
            "Qty": qty,
            "UnitPrice": rate,
            "TaxCodeRef": { "value": "NON" }
          }
        });

        calculatedTotal += amount;
      }
    }

    // ‚úÖ Update the invoice total based on actual calculations
    invoiceData.TotalAmt = calculatedTotal;

    // ‚úÖ Overwrite SKU and Sales Description with correct values from QuickBooks
    invoiceData.Line.forEach((line) => {
      if (line.SalesItemLineDetail) {
        var itemId = line.SalesItemLineDetail.ItemRef.value;
        var correctSKU = getItemNameById(itemId); // Fetch correct SKU from QuickBooks

        if (correctSKU && line.Description !== correctSKU) {
          Logger.log(`üîÑ Overwriting SKU in Description: ${line.Description} ‚Üí ${correctSKU}`);
          line.Description = correctSKU;  // Replace with correct SKU
        }
      }
    });

    Logger.log("üí∞ Final Calculated Total: " + invoiceData.TotalAmt);
    Logger.log("üì§ Sending Invoice Update (UPDATE): " + JSON.stringify(invoiceData));

    // ‚úÖ Push the updated invoice to QuickBooks
    updateInvoiceInQBO(invoiceData);

  } catch (error) {
    Logger.log("‚ùå Error in pushInvoiceToQBO: " + error.message);
  }
}


function updateInvoiceInQBO(invoiceData) {
  checkRateLimit();

  try {
    const accessToken = getAccessToken();
    if (!accessToken) {
      Logger.log("‚ùå No access token, cannot update invoice.");
      return;
    }

    // ‚úÖ Fetch existing invoice details to get SyncToken, Customer ID, and Email
    const existingInvoice = getInvoiceByDocNumber(invoiceData.DocNumber);
    if (!existingInvoice || !existingInvoice.Id || !existingInvoice.SyncToken) {
      Logger.log("‚ùå Could not retrieve invoice details for updating.");
      return;
    }

    // ‚úÖ Preserve critical fields (Customer ID, SyncToken, Email)
    invoiceData.Id = existingInvoice.Id;
    invoiceData.SyncToken = existingInvoice.SyncToken;
    invoiceData.CustomerRef = { "value": existingInvoice.CustomerRef.value }; // Ensure correct Customer ID

    // ‚úÖ Preserve BillEmail if it exists
    if (existingInvoice.BillEmail && existingInvoice.BillEmail.Address) {
      invoiceData.BillEmail = { "Address": existingInvoice.BillEmail.Address };
      Logger.log("üìß Preserved Email: " + existingInvoice.BillEmail.Address);
    } else {
      // ‚úÖ Fetch email from customer profile if missing
      const customerEmail = getCustomerEmailById(existingInvoice.CustomerRef.value);
      if (customerEmail) {
        invoiceData.BillEmail = { "Address": customerEmail };
        Logger.log("üìß Retrieved Customer Email: " + customerEmail);
      } else {
        Logger.log("‚ö†Ô∏è No email found, skipping BillEmail field.");
      }
    }

    // ‚úÖ Ensure line items have correct calculations
    invoiceData.Line.forEach((line) => {
      if (line.SalesItemLineDetail) {
        var unitPrice = parseFloat(line.SalesItemLineDetail.UnitPrice);
        var qty = parseFloat(line.SalesItemLineDetail.Qty);

        // ‚úÖ Ensure Amount is correctly calculated to avoid QuickBooks 6070 Error
        line.Amount = parseFloat((unitPrice * qty).toFixed(2));

        // ‚úÖ Ensure Tax Code is set
        line.SalesItemLineDetail.TaxCodeRef = { "value": "NON" };
      }
    });

    const apiUrl = BASE_URL + COMPANY_ID + "/invoice";

    const headers = {
      "Authorization": "Bearer " + accessToken,
      "Accept": "application/json",
      "Content-Type": "application/json"
    };

    const payload = JSON.stringify(invoiceData);
    Logger.log("üì§ Sending Invoice Update (UPDATE): " + payload);

    const options = {
      method: "post",
      headers: headers,
      muteHttpExceptions: true,
      payload: payload
    };

    let response = fetchWithRetry(apiUrl, options);
    let responseJson = JSON.parse(response.getContentText());

    if (response.getResponseCode() === 200) {
      Logger.log("‚úÖ QuickBooks API Update Successful!");
      return;
    } 
    
    // ‚úÖ Handle API Errors
    else if (responseJson.Fault && responseJson.Fault.Error) {
      let errorCode = responseJson.Fault.Error[0].code;

      // ‚úÖ Ensure retryCount is properly initialized
      if (typeof invoiceData.retryCount === "undefined") {
        invoiceData.retryCount = 0; // Initialize retry count only once
      }

      if (errorCode === "5010" && invoiceData.retryCount < 3) { // üõë Stale Object Error
        Logger.log("‚ö†Ô∏è Stale Object Error Detected! Fetching latest SyncToken...");

        const syncTokens = getAllSyncTokens([invoiceData.Id]); // Fetch in batch
        let latestSyncToken = syncTokens[invoiceData.Id];

        if (!latestSyncToken) {
          Logger.log("‚ùå Failed to fetch the latest SyncToken. Update aborted.");
          return;
        }

        invoiceData.SyncToken = latestSyncToken;
        invoiceData.retryCount++; // Increment retry count
        Logger.log(`üîÑ Retrying update (Attempt ${invoiceData.retryCount}) with new SyncToken: ${latestSyncToken}`);

        return updateInvoiceInQBO(invoiceData); // Retry with new token
      } else if (invoiceData.retryCount >= 3) {
        Logger.log("‚ùå Max retries reached for Stale Object Error. Update aborted.");
        return; // üî¥ Prevents further execution after max retries
      }

      // üöÄ **Remove retryCount before sending to QuickBooks**
      delete invoiceData.retryCount;

      // ‚úÖ Proceed with the final API request
      const response = fetchWithRetry(apiUrl, options);
      Logger.log("‚úÖ QuickBooks API Response: " + response.getContentText());

      if (response && response.getResponseCode() !== 200) { 
        let responseJson = JSON.parse(response.getContentText());
        if (responseJson.Fault) {
          Logger.log("‚ùå API Error: " + JSON.stringify(responseJson.Fault));
        }
      }
    }
  } catch (error) {
    Logger.log("‚ùå Error in updateInvoiceInQBO: " + error.message);
  }
}
