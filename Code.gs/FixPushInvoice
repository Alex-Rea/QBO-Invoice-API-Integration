function pushInvoiceToQBO(sheet) {
  checkRateLimit();  // üõ° Prevent hitting API rate limits

  try {
    Logger.log("üìå Starting invoice sync for sheet: " + sheet.getName());

    // ‚úÖ Extract invoice details from the sheet
    var invoiceNumber = sheet.getRange("A1").getValue().replace("Invoice Number: ", "").trim();
    var txnDate = sheet.getRange("A2").getValue().replace("Date: ", "").trim();
    var customer = sheet.getRange("A3").getValue().replace("Customer: ", "").trim();
    var total = parseFloat(sheet.getRange("A4").getValue().replace("Total: $", "").trim());

    Logger.log("üìÜ Transaction Date: " + txnDate);
    Logger.log("üë§ Customer Name: " + customer);
    Logger.log("üí∞ Invoice Total: " + total);

    // ‚úÖ Check if the invoice already exists in QuickBooks
    var invoiceId = getInvoiceIdByDocNumber(invoiceNumber);
    if (!invoiceId) {
      Logger.log("‚ùå Invoice not found. Creating a new invoice.");
      createInvoiceInQBO(sheet);
      return;
    }

    // ‚úÖ Fetch SyncToken for the existing invoice
    var syncTokens = getAllSyncTokens([invoiceId]);
    var syncToken = syncTokens[invoiceId] || "0";  // Use default "0" if missing

    // ‚úÖ Prepare the invoice data for update
    var invoiceData = {
      "Id": invoiceId,
      "SyncToken": syncToken,
      "DocNumber": invoiceNumber,
      "TxnDate": txnDate,
      "CustomerRef": { "name": customer },
      "TotalAmt": 0,  // Will be calculated dynamically
      "Line": []
    };

    Logger.log("üîÑ Collecting line items for invoice...");

    // ‚úÖ Read line items from the sheet
    var lastRow = sheet.getLastRow();
    var calculatedTotal = 0;

    for (var row = 7; row <= lastRow; row++) {
      var itemName = sheet.getRange("A" + row).getValue().trim();
      var qty = parseFloat(sheet.getRange("B" + row).getValue());
      var rate = parseFloat(sheet.getRange("C" + row).getValue());
      var amount = parseFloat(sheet.getRange("D" + row).getValue());
      var itemRef = sheet.getRange("E" + row).getValue();

      // ‚úÖ Add line item if all fields are valid
      if (itemName && qty && rate && amount && itemRef) {
        Logger.log(`üõí Item: ${itemName} | Qty: ${qty} | Rate: ${rate} | Amount: ${amount} | ItemRef: ${itemRef}`);

        invoiceData.Line.push({
          "DetailType": "SalesItemLineDetail",
          "Amount": amount,
          "Description": itemName,  // Initially set to the sheet-provided name
          "SalesItemLineDetail": {
            "ItemRef": { "value": String(itemRef) },
            "Qty": qty,
            "UnitPrice": rate,
            "TaxCodeRef": { "value": "NON" }
          }
        });

        calculatedTotal += amount;
      }
    }

    // ‚úÖ Update the invoice total based on actual calculations
    invoiceData.TotalAmt = calculatedTotal;

    // ‚úÖ Overwrite item names with correct names from QuickBooks (if mismatched)
    invoiceData.Line.forEach((line) => {
      if (line.SalesItemLineDetail) {
        var itemId = line.SalesItemLineDetail.ItemRef.value;
        var correctName = getItemNameById(itemId); // Fetch correct name from QuickBooks

        if (correctName && line.Description !== correctName) {
          Logger.log(`üîÑ Overwriting Description: ${line.Description} ‚Üí ${correctName}`);
          line.Description = correctName;  // Fix mismatched item names
        }
      }
    });

    Logger.log("üí∞ Final Calculated Total: " + invoiceData.TotalAmt);
    Logger.log("üì§ Sending Invoice Update (UPDATE): " + JSON.stringify(invoiceData));

    // ‚úÖ Push the updated invoice to QuickBooks
    updateInvoiceInQBO(invoiceData);

  } catch (error) {
    Logger.log("‚ùå Error in pushInvoiceToQBO: " + error.message);
  }
}


function updateInvoiceInQBO(invoiceData) {
  checkRateLimit();

  try {
    const accessToken = getAccessToken();
    if (!accessToken) {
      Logger.log("‚ùå No access token, cannot update invoice.");
      return;
    }

    // ‚úÖ Fetch existing invoice details to get SyncToken, Customer ID, and Email
    const existingInvoice = getInvoiceByDocNumber(invoiceData.DocNumber);
    if (!existingInvoice || !existingInvoice.Id || !existingInvoice.SyncToken) {
      Logger.log("‚ùå Could not retrieve invoice details for updating.");
      return;
    }

    // ‚úÖ Preserve critical fields (Customer ID, SyncToken, Email)
    invoiceData.Id = existingInvoice.Id;
    invoiceData.SyncToken = existingInvoice.SyncToken;
    invoiceData.CustomerRef = { "value": existingInvoice.CustomerRef.value }; // Ensure correct Customer ID

    // ‚úÖ Preserve BillEmail if it exists
    if (existingInvoice.BillEmail && existingInvoice.BillEmail.Address) {
      invoiceData.BillEmail = { "Address": existingInvoice.BillEmail.Address };
      Logger.log("üìß Preserved Email: " + existingInvoice.BillEmail.Address);
    } else {
      // ‚úÖ Fetch email from customer profile if missing
      const customerEmail = getCustomerEmailById(existingInvoice.CustomerRef.value);
      if (customerEmail) {
        invoiceData.BillEmail = { "Address": customerEmail };
        Logger.log("üìß Retrieved Customer Email: " + customerEmail);
      } else {
        Logger.log("‚ö†Ô∏è No email found, skipping BillEmail field.");
      }
    }

    // ‚úÖ Ensure line items have correct calculations
    invoiceData.Line.forEach((line) => {
      if (line.SalesItemLineDetail) {
        var unitPrice = parseFloat(line.SalesItemLineDetail.UnitPrice);
        var qty = parseFloat(line.SalesItemLineDetail.Qty);

        // ‚úÖ Ensure Amount is correctly calculated to avoid QuickBooks 6070 Error
        line.Amount = parseFloat((unitPrice * qty).toFixed(2));

        // ‚úÖ Ensure Tax Code is set
        line.SalesItemLineDetail.TaxCodeRef = { "value": "NON" };
      }
    });

    const apiUrl = BASE_URL + COMPANY_ID + "/invoice";

    const headers = {
      "Authorization": "Bearer " + accessToken,
      "Accept": "application/json",
      "Content-Type": "application/json"
    };

    const payload = JSON.stringify(invoiceData);
    Logger.log("üì§ Sending Invoice Update (UPDATE): " + payload);

    const options = {
      method: "post",
      headers: headers,
      muteHttpExceptions: true,
      payload: payload
    };

    let response = fetchWithRetry(apiUrl, options);
    let responseJson = JSON.parse(response.getContentText());

    if (response.getResponseCode() === 200) {
      Logger.log("‚úÖ QuickBooks API Update Successful!");
      return;
    } 
    
    // ‚úÖ Handle API Errors
    else if (responseJson.Fault && responseJson.Fault.Error) {
      let errorCode = responseJson.Fault.Error[0].code;

      // ‚úÖ Ensure retryCount is properly initialized
      if (typeof invoiceData.retryCount === "undefined") {
        invoiceData.retryCount = 0; // Initialize retry count only once
      }

if (errorCode === "5010" && invoiceData.retryCount < 3) { // üõë Stale Object Error
    Logger.log("‚ö†Ô∏è Stale Object Error Detected! Fetching latest SyncToken...");

    const syncTokens = getAllSyncTokens([invoiceData.Id]); // Fetch in batch
    let latestSyncToken = syncTokens[invoiceData.Id];

    if (!latestSyncToken) {
        Logger.log("‚ùå Failed to fetch the latest SyncToken. Update aborted.");
        return;
    }

    invoiceData.SyncToken = latestSyncToken;
    invoiceData.retryCount++; // Increment retry count
    Logger.log(`üîÑ Retrying update (Attempt ${invoiceData.retryCount}) with new SyncToken: ${latestSyncToken}`);

    return updateInvoiceInQBO(invoiceData); // Retry with new token
} else if (invoiceData.retryCount >= 3) {
    Logger.log("‚ùå Max retries reached for Stale Object Error. Update aborted.");
    return; // üî¥ Prevents further execution after max retries
}

// üöÄ **Remove retryCount before sending to QuickBooks**
delete invoiceData.retryCount;

// ‚úÖ Proceed with the final API request
const response = fetchWithRetry(apiUrl, options);
Logger.log("‚úÖ QuickBooks API Response: " + response.getContentText());

if (response && response.getResponseCode() !== 200) { 
    let responseJson = JSON.parse(response.getContentText());
    if (responseJson.Fault) {
        Logger.log("‚ùå API Error: " + JSON.stringify(responseJson.Fault));
    }
}


    }
  } catch (error) {
    Logger.log("‚ùå Error in updateInvoiceInQBO: " + error.message);
  }
}
