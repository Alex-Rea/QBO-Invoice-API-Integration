var requestCount = 0;
var scriptProperties = PropertiesService.getScriptProperties();

// üåê Cloud KMS Config
const PROJECT_ID = "qbo-api-invoice-integration";
const LOCATION_ID = "global"; // Change if using a specific region
const KEY_RING_ID = "my-key-ring";
const KEY_ID = "my-encryption-key";
const BASE_URL = "https://sandbox-quickbooks.api.intuit.com/v3/company/";
const COMPANY_ID = PropertiesService.getScriptProperties().getProperty("COMPANY_ID");


// üõ† Cached Auth Tokens
var lastKmsToken = null;
var lastKmsTokenTime = null;
var lastAccessToken = null;
var lastTokenTime = null;

// üìÇ Service Account Credentials
function getServiceAccountCredentials() {
    var fileId = "1cRPEPieERuPVbePVBQOoscfI3vJkj7DM"; // Replace with your actual Google Drive file ID
    var file = DriveApp.getFileById(fileId);
    var jsonKey = file.getBlob().getDataAsString();
    return JSON.parse(jsonKey);
}

// üîë Get OAuth Token for Cloud KMS
function getAuthToken() {
    var now = new Date().getTime();
    if (lastKmsToken && lastKmsTokenTime && now - lastKmsTokenTime < 3600000) {
        Logger.log("‚úÖ Using cached Cloud KMS Auth Token.");
        return lastKmsToken;
    }

    var credentials = getServiceAccountCredentials();
    var tokenResponse = UrlFetchApp.fetch("https://oauth2.googleapis.com/token", {
        method: "post",
        contentType: "application/json",
        payload: JSON.stringify({
            grant_type: "urn:ietf:params:oauth:grant-type:jwt-bearer",
            assertion: createJwt(credentials)
        })
    });

    var response = JSON.parse(tokenResponse.getContentText());
    if (response.access_token) {
        lastKmsToken = response.access_token;
        lastKmsTokenTime = now;
        return lastKmsToken;
    }

    Logger.log("‚ùå Failed to get Cloud KMS Auth Token.");
    return null;
}

// üîê Create JWT for Cloud KMS Authentication
function createJwt(credentials) {
    var now = Math.floor(Date.now() / 1000);
    var payload = {
        iss: credentials.client_email,
        scope: "https://www.googleapis.com/auth/cloudkms",
        aud: "https://oauth2.googleapis.com/token",
        exp: now + 3600,
        iat: now
    };

    var encodedHeader = Utilities.base64EncodeWebSafe(JSON.stringify({ alg: "RS256", typ: "JWT" }));
    var encodedPayload = Utilities.base64EncodeWebSafe(JSON.stringify(payload));
    var signatureInput = encodedHeader + "." + encodedPayload;
    var signature = Utilities.computeRsaSha256Signature(signatureInput, credentials.private_key);
    return signatureInput + "." + Utilities.base64EncodeWebSafe(signature);
}


// üîí Encrypt Data with Cloud KMS (Optimized)
function encryptWithKMS(plainText) {
    if (!lastKmsToken) lastKmsToken = getAuthToken(); // Only fetch if missing

    var url = `https://cloudkms.googleapis.com/v1/projects/${PROJECT_ID}/locations/${LOCATION_ID}/keyRings/${KEY_RING_ID}/cryptoKeys/${KEY_ID}:encrypt`;
    var requestBody = { plaintext: Utilities.base64Encode(plainText) };

    var response = UrlFetchApp.fetch(url, {
        method: "post",
        headers: { Authorization: `Bearer ${lastKmsToken}`, "Content-Type": "application/json" },
        payload: JSON.stringify(requestBody)
    });

    return JSON.parse(response.getContentText()).ciphertext;
}

// üîì Decrypt Data with Cloud KMS (Optimized)
function decryptWithKMS(encryptedText) {
    if (!lastKmsToken) lastKmsToken = getAuthToken(); // Only fetch if missing

    var url = `https://cloudkms.googleapis.com/v1/projects/${PROJECT_ID}/locations/${LOCATION_ID}/keyRings/${KEY_RING_ID}/cryptoKeys/${KEY_ID}:decrypt`;
    var requestBody = { ciphertext: encryptedText };

    var response = UrlFetchApp.fetch(url, {
        method: "post",
        headers: { Authorization: `Bearer ${lastKmsToken}`, "Content-Type": "application/json" },
        payload: JSON.stringify(requestBody)
    });

    return Utilities.newBlob(
        Utilities.base64Decode(JSON.parse(response.getContentText()).plaintext)
    ).getDataAsString();
}


function getAccessToken() {
    checkRateLimit();

    var now = new Date().getTime();

    // ‚úÖ Use Cached Token if Still Valid
    if (lastAccessToken && lastTokenTime && now - lastTokenTime < 3600000) {
        Logger.log("‚úÖ Using Cached Access Token.");
        return lastAccessToken;
    }

    // üîë Retrieve encrypted QuickBooks credentials
    var credentials = getDecryptedClientCredentials();
    if (!credentials || !credentials.CLIENT_ID || !credentials.CLIENT_SECRET) {
        Logger.log("‚ùå Missing QuickBooks credentials! Cannot retrieve access token.");
        return null;
    }

    // üîí Retrieve & Decrypt the Securely Stored Refresh Token
    var encryptedRefreshToken = PropertiesService.getScriptProperties().getProperty("ENCRYPTED_REFRESH_TOKEN");
    if (!encryptedRefreshToken) {
        Logger.log("‚ùå No valid refresh token found. Reauthorization required.");
        return null;
    }

    var decryptedRefreshToken = decryptWithKMS(encryptedRefreshToken);
    if (!decryptedRefreshToken) {
        Logger.log("‚ùå Decryption failed: Refresh token is invalid.");
        return null;
    }

    const tokenUrl = "https://oauth.platform.intuit.com/oauth2/v1/tokens/bearer";
    const headers = { "Content-Type": "application/x-www-form-urlencoded" };
    const payload = "grant_type=refresh_token"
                  + "&refresh_token=" + encodeURIComponent(decryptedRefreshToken)
                  + "&client_id=" + encodeURIComponent(credentials.CLIENT_ID)
                  + "&client_secret=" + encodeURIComponent(credentials.CLIENT_SECRET);

    const options = { method: "post", headers: headers, payload: payload, muteHttpExceptions: true };

    // üîÑ Fetch Token With Retry Logic
    const response = fetchWithRetry(tokenUrl, options);
    if (!response || response.getResponseCode() !== 200) {
        Logger.log("‚ùå Failed to retrieve access token. Response: " + response.getContentText());
        return null;
    }

    const json = JSON.parse(response.getContentText());
    if (json.access_token) {
        Logger.log("‚úÖ Access Token Retrieved.");
        lastAccessToken = json.access_token;
        lastTokenTime = now;

        // ‚úÖ Only Store a New Refresh Token If QuickBooks Returns One
        if (json.refresh_token && json.refresh_token !== decryptedRefreshToken) {
            storeRefreshToken(json.refresh_token);
            Logger.log("üîÑ Updated REFRESH TOKEN securely stored.");
        }

        return json.access_token;
    } else {
        Logger.log("‚ùå Error retrieving access token: " + response.getContentText());
        return null;
    }
}

// üîÑ Store Securely Encrypted Refresh Token
function storeRefreshToken(refreshToken) {
    var encryptedToken = encryptWithKMS(refreshToken); // Encrypt the token using KMS
    PropertiesService.getScriptProperties().setProperty("ENCRYPTED_REFRESH_TOKEN", encryptedToken);
    Logger.log("üîí Securely stored new refresh token.");
}





// üõ† Securely Store QuickBooks Credentials
function storeClientCredentials(clientId, clientSecret) {
    PropertiesService.getScriptProperties().setProperty("ENCRYPTED_CLIENT_ID", encryptWithKMS(clientId));
    PropertiesService.getScriptProperties().setProperty("ENCRYPTED_CLIENT_SECRET", encryptWithKMS(clientSecret));
    Logger.log("üîí QuickBooks credentials securely stored with Cloud KMS.");
}

// üîë Retrieve & Decrypt QuickBooks Credentials
function getDecryptedClientCredentials() {
    var encryptedClientId = PropertiesService.getScriptProperties().getProperty("ENCRYPTED_CLIENT_ID");
    var encryptedClientSecret = PropertiesService.getScriptProperties().getProperty("ENCRYPTED_CLIENT_SECRET");

    if (!encryptedClientId || !encryptedClientSecret) return Logger.log("‚ùå No stored credentials found.");

    return {
        CLIENT_ID: decryptWithKMS(encryptedClientId),
        CLIENT_SECRET: decryptWithKMS(encryptedClientSecret)
    };
}





function checkRateLimit() {
  requestCount++;
  if (requestCount % 5 === 0) {  // Every 5 requests, wait 1.5 seconds
    Logger.log("‚è≥ Adding delay to prevent hitting QuickBooks rate limits...");
    Utilities.sleep(1500);
  }
}


function refreshInvoices() {
  checkRateLimit();

  var ss = SpreadsheetApp.getActiveSpreadsheet();
  var menuSheet = ss.getSheetByName("Menu");

  if (!menuSheet) {
    Logger.log("‚ùå Error: 'Menu' sheet not found.");
    return;
  }

  // ‚úÖ Step 1: Check if A2 and A3 are both checked
  var checkA2 = menuSheet.getRange("A2").getValue();
  var checkA3 = menuSheet.getRange("A3").getValue();

  if (!(checkA2 && checkA3)) {
    Logger.log("‚ùå A2 and A3 must be checked to refresh invoices.");
    return;
  }

  Logger.log("‚úÖ Both checkboxes checked in 'Menu'! Refreshing Invoices...");

  // ‚úÖ Step 2: Delete all existing invoice sheets
  var sheets = ss.getSheets();
  var invoiceSheets = sheets.filter(sheet => sheet.getName().startsWith("Inv_"));
  Logger.log("üóë Found " + invoiceSheets.length + " invoice sheets to delete.");

  invoiceSheets.forEach(sheet => {
    try {
      ss.deleteSheet(sheet);
      Logger.log("üóë Deleted: " + sheet.getName());
    } catch (e) {
      Logger.log("‚ö†Ô∏è Skipping already deleted sheet: " + e.message);
    }
  });

  // ‚úÖ Step 3: Fetch new invoices from QuickBooks
  var accessToken = getAccessToken();
  if (!accessToken) {
    Logger.log("‚ùå No access token retrieved!");
    return;
  }

  var query = "SELECT * FROM Invoice ORDERBY TxnDate DESC STARTPOSITION 1 MAXRESULTS 10";
  var apiUrl = BASE_URL + COMPANY_ID + "/query?query=" + encodeURIComponent(query);

  var headers = {
    "Authorization": "Bearer " + accessToken,
    "Accept": "application/json"
  };

  var options = {
    method: "get",
    headers: headers,
    muteHttpExceptions: true
  };

  var response = fetchWithRetry(apiUrl, options);
  var json = JSON.parse(response.getContentText());

  if (json.Fault) {
    Logger.log("‚ùå API Error: " + JSON.stringify(json.Fault));
    return;
  }

  if (!json.QueryResponse || !json.QueryResponse.Invoice) {
    Logger.log("‚ö†Ô∏è No invoices found in QuickBooks!");
    return;
  }

  var invoices = json.QueryResponse.Invoice;
  Logger.log("‚úÖ Invoices Retrieved: " + invoices.length);

// ‚úÖ Step 4: Create new invoice sheets & store links with `gid`
var invoiceLinks = [];
var invoiceDescriptions = [];

invoices.forEach(function(invoice) {
  var invoiceNumber = invoice.DocNumber || "Invoice_" + invoice.Id;
  var invoiceTabName = "Inv_" + invoiceNumber;
  var customerName = invoice.CustomerRef && invoice.CustomerRef.name ? invoice.CustomerRef.name : "Unknown Customer";

  var newSheet = ss.insertSheet(invoiceTabName);
  formatInvoiceSheet(newSheet, invoice);

  // ‚úÖ Use `gid` for links
  var sheetGid = newSheet.getSheetId();
  var linkFormula = `=HYPERLINK("https://docs.google.com/spreadsheets/d/${ss.getId()}/edit#gid=${sheetGid}", "${invoiceNumber}")`;
  
  invoiceLinks.push([linkFormula]);         // Column A (Invoice Links)
  invoiceDescriptions.push([customerName]); // Column B (Customer Name)
});

// ‚úÖ Place links in "Menu" (A5:A10) & customer names in (B5:B10)
var menuSheet = ss.getSheetByName("Menu");
var linkRange = menuSheet.getRange(5, 1, invoiceLinks.length, 1);
var descRange = menuSheet.getRange(5, 2, invoiceDescriptions.length, 1);

linkRange.setFormulas(invoiceLinks);
descRange.setValues(invoiceDescriptions);



  // ‚úÖ Step 6: Reset A2 & A3 checkboxes
  menuSheet.getRange("A2").setValue(false);
  menuSheet.getRange("A3").setValue(false);

  Logger.log("‚úÖ Invoice refresh complete!");
}




function formatInvoiceSheet(newSheet, invoice) {
  newSheet.getRange("A1").setValue("Invoice Number: " + (invoice.DocNumber || "N/A"));
  newSheet.getRange("A2").setValue("Date: " + (invoice.TxnDate || "N/A"));
  newSheet.getRange("A3").setValue("Customer: " + (invoice.CustomerRef ? invoice.CustomerRef.name : "Unknown"));
  
  // ‚úÖ Auto-updating total
  newSheet.getRange("A4").setFormula('="Total: $" & SUM(D7:D)');

  newSheet.getRange("A6").setValue("Item");
  newSheet.getRange("B6").setValue("Quantity");
  newSheet.getRange("C6").setValue("Rate");
  newSheet.getRange("D6").setValue("Amount");
  newSheet.getRange("E6").setValue("ItemRef"); // Store ItemRef for QBO

var row = 7;

  if (invoice.Line && invoice.Line.length > 0) {
    invoice.Line.forEach(function(line) {
      if (line.SalesItemLineDetail) {
        var itemRef = line.SalesItemLineDetail.ItemRef ? line.SalesItemLineDetail.ItemRef.value : "N/A";
        
        // ‚úÖ **Extract the actual Item Name instead of Sales Description**
        var itemName = (itemRef && itemRef !== "N/A") ? getItemNameById(itemRef) : "Unknown";
        newSheet.getRange("A" + row).setValue(itemName);
        newSheet.getRange("B" + row).setValue(line.SalesItemLineDetail.Qty || 0);
        newSheet.getRange("C" + row).setValue(line.SalesItemLineDetail.UnitPrice || 0);
        newSheet.getRange("D" + row).setFormula("=B" + row + "*C" + row);
        newSheet.getRange("E" + row).setValue(itemRef); // Store ItemRef

        row++;
      }
    });
  } else {
    newSheet.getRange("A7").setValue("‚ö†Ô∏è No items found for this invoice.");
  }

  newSheet.getRange("D1").setValue("Push Changes");
  newSheet.getRange("D2").insertCheckboxes();
  newSheet.getRange("D3").insertCheckboxes();
}


function getAllSyncTokens(invoiceIds) {
  if (!invoiceIds.length) {
    return {};
  }

  checkRateLimit();

  const accessToken = getAccessToken();
  if (!accessToken) {
    Logger.log("‚ùå No access token, cannot fetch SyncTokens.");
    return {};
  }

  const query = "SELECT Id, SyncToken FROM Invoice WHERE Id IN (" + invoiceIds.map(id => `'${id}'`).join(",") + ")";
  const apiUrl = BASE_URL + COMPANY_ID + "/query?query=" + encodeURIComponent(query);

  const headers = {
    "Authorization": "Bearer " + accessToken,
    "Accept": "application/json"
  };

  const options = {
    method: "get",
    headers: headers,
    muteHttpExceptions: true
  };

  const response = fetchWithRetry(apiUrl, options);
  const json = JSON.parse(response.getContentText());

  let syncTokenMap = {};
  if (json.QueryResponse && json.QueryResponse.Invoice) {
    json.QueryResponse.Invoice.forEach(invoice => {
      syncTokenMap[invoice.Id] = invoice.SyncToken;
    });
    Logger.log("‚úÖ Retrieved SyncTokens for " + json.QueryResponse.Invoice.length + " invoices.");
  } else {
    Logger.log("‚ùå Failed to retrieve SyncTokens.");
  }

  return syncTokenMap;
}

function getInvoiceByDocNumber(docNumber) {
  checkRateLimit();

  try {
    const accessToken = getAccessToken();
    if (!accessToken) {
      Logger.log("‚ùå No access token, cannot retrieve invoice.");
      return null;
    }

    const query = "SELECT Id, SyncToken, CustomerRef FROM Invoice WHERE DocNumber = '" + docNumber + "'";
    const apiUrl = BASE_URL + COMPANY_ID + "/query?query=" + encodeURIComponent(query);

    const headers = {
      "Authorization": "Bearer " + accessToken,
      "Accept": "application/json"
    };

    const options = {
      method: "get",
      headers: headers,
      muteHttpExceptions: true
    };

    const response = fetchWithRetry(apiUrl, options);
    const json = JSON.parse(response.getContentText());

    if (json.QueryResponse && json.QueryResponse.Invoice && json.QueryResponse.Invoice.length > 0) {
      const invoice = json.QueryResponse.Invoice[0];

      Logger.log("‚úÖ Invoice found: " + JSON.stringify(invoice)); // üîÑ Keep logging for debugging

      if (!invoice.Id || !invoice.SyncToken) {
        Logger.log("‚ö†Ô∏è Invoice data is missing critical fields (Id/SyncToken).");
        return null;
      }

      return invoice;
    } else {
      Logger.log("‚ùå Invoice not found for DocNumber: " + docNumber);
      return null;
    }

  } catch (error) {  // ‚úÖ Missing catch block added here!
    Logger.log("‚ùå Error in getInvoiceByDocNumber: " + error.message);
    return null;
  }
}


function getInvoiceIdByDocNumber(docNumber) {
  checkRateLimit();

  const accessToken = getAccessToken();
  if (!accessToken) {
    Logger.log("‚ùå No access token, cannot fetch invoice ID.");
    return null;
  }

  const query = "SELECT Id FROM Invoice WHERE DocNumber = '" + docNumber + "'";
  const apiUrl = BASE_URL + COMPANY_ID + "/query?query=" + encodeURIComponent(query);

  const headers = {
    "Authorization": "Bearer " + accessToken,
    "Accept": "application/json"
  };

  const options = {
    method: "get",
    headers: headers,
    muteHttpExceptions: true
  };

  const response = fetchWithRetry(apiUrl, options);
  const json = JSON.parse(response.getContentText());

  if (json.QueryResponse && json.QueryResponse.Invoice && json.QueryResponse.Invoice.length > 0) {
    Logger.log("‚úÖ Invoice found: " + JSON.stringify(json.QueryResponse.Invoice[0]));
    return json.QueryResponse.Invoice[0].Id;
  } else {
    Logger.log("‚ùå No existing invoice found for DocNumber: " + docNumber);
    return null;
  }
}


function getItemNameById(itemId) {
  checkRateLimit();

  if (!itemId || itemId === "N/A") {
    Logger.log("‚ö†Ô∏è Skipping item lookup: No valid item ID.");
    return null;
  }
  Utilities.sleep(1000);  // ‚úÖ 1-second delay to prevent rate limiting

  const accessToken = getAccessToken();
  if (!accessToken) {
    Logger.log("‚ùå No access token, cannot fetch item name.");
    return null;
  }

  const query = "SELECT Name FROM Item WHERE Id = '" + itemId + "'";
  const apiUrl = BASE_URL + COMPANY_ID + "/query?query=" + encodeURIComponent(query);

  const headers = {
    "Authorization": "Bearer " + accessToken,
    "Accept": "application/json"
  };

  const options = {
    method: "get",
    headers: headers,
    muteHttpExceptions: true
  };

  const response = fetchWithRetry(apiUrl, options);
  const json = JSON.parse(response.getContentText());

  if (json.QueryResponse && json.QueryResponse.Item && json.QueryResponse.Item.length > 0) {
    Logger.log("‚úÖ Item Found: " + JSON.stringify(json.QueryResponse.Item[0]));
    return json.QueryResponse.Item[0].Name;
  } else {
    Logger.log("‚ùå Item ID not found in QuickBooks: " + itemId);
    return null;
  }
}

function getCustomerIdByName(customerName) {
  if (!customerName) {
    Logger.log("‚ùå No customer name provided.");
    return null;
  }

  // ‚úÖ Use cached data if available
  if (customerCache[customerId]) {
    return customerCache[customerId].email;
  }

  const accessToken = getAccessToken();
  if (!accessToken) {
    Logger.log("‚ùå No access token, cannot fetch customer.");
    return null;
  }

const query = "SELECT Id, DisplayName FROM Customer WHERE DisplayName = '" + customerName + "'";
  const apiUrl = BASE_URL + COMPANY_ID + "/query?query=" + encodeURIComponent(query);

  const headers = {
    "Authorization": "Bearer " + accessToken,
    "Accept": "application/json"
  };

  const options = {
    method: "get",
    headers: headers,
    muteHttpExceptions: true
  };

  const response = fetchWithRetry(apiUrl, options);
  const json = JSON.parse(response.getContentText());

  if (json.Customer && json.Customer.PrimaryEmailAddr) {
    const email = json.Customer.PrimaryEmailAddr.Address;
    customerCache[customerId] = { email: email };  // ‚úÖ Cache the email
    Logger.log("‚úÖ Customer email found: " + email);
    return email;
  } else {
    Logger.log("‚ö†Ô∏è No email found for Customer ID: " + customerId);
    return null;
  }
}


function getItemRefByName(itemName) {
  checkRateLimit();

  const accessToken = getAccessToken();
  if (!accessToken) {
    Logger.log("‚ùå No access token, cannot fetch item.");
    return null;
  }

  const query = "SELECT Id, Name FROM Item WHERE Name = '" + itemName + "'";
  const apiUrl = BASE_URL + COMPANY_ID + "/query?query=" + encodeURIComponent(query);

  const headers = {
    "Authorization": "Bearer " + accessToken,
    "Accept": "application/json"
  };

  const options = {
    method: "get",
    headers: headers,
    muteHttpExceptions: true
  };

  const response = fetchWithRetry(apiUrl, options);
  const json = JSON.parse(response.getContentText());

  if (json.QueryResponse && json.QueryResponse.Item && json.QueryResponse.Item.length > 0) {
    Logger.log("‚úÖ Item found: " + JSON.stringify(json.QueryResponse.Item[0]));
    return {
      value: json.QueryResponse.Item[0].Id,
      name: json.QueryResponse.Item[0].Name
    };
  } else {
    Logger.log("‚ùå Item not found in QuickBooks: " + itemName);
    return null;
  }
}

var customerCache = {};  // ‚úÖ Store customer details in memory

function getCustomerEmailById(customerId) {
  checkRateLimit();

  if (!customerId) {
    Logger.log("‚ùå No customer ID provided.");
    return null;
  }

  // ‚úÖ Return from cache if available
  if (customerCache[customerId]) {
    return customerCache[customerId].email;
  }

  const accessToken = getAccessToken();
  if (!accessToken) {
    Logger.log("‚ùå No access token, cannot fetch customer email.");
    return null;
  }

  const apiUrl = BASE_URL + COMPANY_ID + "/customer/" + customerId;

  const headers = {
    "Authorization": "Bearer " + accessToken,
    "Accept": "application/json"
  };

  const options = {
    method: "get",
    headers: headers,
    muteHttpExceptions: true
  };

  const response = fetchWithRetry(apiUrl, options);
  const json = JSON.parse(response.getContentText());

  if (json.Customer && json.Customer.PrimaryEmailAddr) {
    const email = json.Customer.PrimaryEmailAddr.Address;
    customerCache[customerId] = { email: email };  // ‚úÖ Cache the email
    Logger.log("‚úÖ Customer email found: " + email);
    return email;
  } else {
    Logger.log("‚ö†Ô∏è No email found for Customer ID: " + customerId);
    return null;
  }
}



function updateInvoiceInQBO(invoiceData) {
  checkRateLimit();

  try {
    const accessToken = getAccessToken();
    if (!accessToken) {
      Logger.log("‚ùå No access token, cannot update invoice.");
      return;
    }

    // ‚úÖ Fetch existing invoice details to get SyncToken, Customer ID, and Email
    const existingInvoice = getInvoiceByDocNumber(invoiceData.DocNumber);
    if (!existingInvoice || !existingInvoice.Id || !existingInvoice.SyncToken) {
      Logger.log("‚ùå Could not retrieve invoice details for updating.");
      return;
    }

    // ‚úÖ Preserve critical fields (Customer ID, SyncToken, Email)
    invoiceData.Id = existingInvoice.Id;
    invoiceData.SyncToken = existingInvoice.SyncToken;
    invoiceData.CustomerRef = { "value": existingInvoice.CustomerRef.value }; // Ensure correct Customer ID

    // ‚úÖ Preserve BillEmail if it exists
    if (existingInvoice.BillEmail && existingInvoice.BillEmail.Address) {
      invoiceData.BillEmail = { "Address": existingInvoice.BillEmail.Address };
      Logger.log("üìß Preserved Email: " + existingInvoice.BillEmail.Address);
    } else {
      // ‚úÖ Fetch email from customer profile if missing
      const customerEmail = getCustomerEmailById(existingInvoice.CustomerRef.value);
      if (customerEmail) {
        invoiceData.BillEmail = { "Address": customerEmail };
        Logger.log("üìß Retrieved Customer Email: " + customerEmail);
      } else {
        Logger.log("‚ö†Ô∏è No email found, skipping BillEmail field.");
      }
    }

    // ‚úÖ Ensure line items have correct calculations
    invoiceData.Line.forEach((line) => {
      if (line.SalesItemLineDetail) {
        var unitPrice = parseFloat(line.SalesItemLineDetail.UnitPrice);
        var qty = parseFloat(line.SalesItemLineDetail.Qty);

        // ‚úÖ Ensure Amount is correctly calculated to avoid QuickBooks 6070 Error
        line.Amount = parseFloat((unitPrice * qty).toFixed(2));

        // ‚úÖ Ensure Tax Code is set
        line.SalesItemLineDetail.TaxCodeRef = { "value": "NON" };
      }
    });

    const apiUrl = BASE_URL + COMPANY_ID + "/invoice";

    const headers = {
      "Authorization": "Bearer " + accessToken,
      "Accept": "application/json",
      "Content-Type": "application/json"
    };

    const payload = JSON.stringify(invoiceData);
    Logger.log("üì§ Sending Invoice Update (UPDATE): " + payload);

    const options = {
      method: "post",
      headers: headers,
      muteHttpExceptions: true,
      payload: payload
    };

    let response = fetchWithRetry(apiUrl, options);
    let responseJson = JSON.parse(response.getContentText());

    if (response.getResponseCode() === 200) {
      Logger.log("‚úÖ QuickBooks API Update Successful!");
      return;
    } 
    
    // ‚úÖ Handle API Errors
    else if (responseJson.Fault && responseJson.Fault.Error) {
      let errorCode = responseJson.Fault.Error[0].code;

      // ‚úÖ Ensure retryCount is properly initialized
      if (typeof invoiceData.retryCount === "undefined") {
        invoiceData.retryCount = 0; // Initialize retry count only once
      }

if (errorCode === "5010" && invoiceData.retryCount < 3) { // üõë Stale Object Error
    Logger.log("‚ö†Ô∏è Stale Object Error Detected! Fetching latest SyncToken...");

    const syncTokens = getAllSyncTokens([invoiceData.Id]); // Fetch in batch
    let latestSyncToken = syncTokens[invoiceData.Id];

    if (!latestSyncToken) {
        Logger.log("‚ùå Failed to fetch the latest SyncToken. Update aborted.");
        return;
    }

    invoiceData.SyncToken = latestSyncToken;
    invoiceData.retryCount++; // Increment retry count
    Logger.log(`üîÑ Retrying update (Attempt ${invoiceData.retryCount}) with new SyncToken: ${latestSyncToken}`);

    return updateInvoiceInQBO(invoiceData); // Retry with new token
} else if (invoiceData.retryCount >= 3) {
    Logger.log("‚ùå Max retries reached for Stale Object Error. Update aborted.");
    return; // üî¥ Prevents further execution after max retries
}

// üöÄ **Remove retryCount before sending to QuickBooks**
delete invoiceData.retryCount;

// ‚úÖ Proceed with the final API request
const response = fetchWithRetry(apiUrl, options);
Logger.log("‚úÖ QuickBooks API Response: " + response.getContentText());

if (response && response.getResponseCode() !== 200) { 
    let responseJson = JSON.parse(response.getContentText());
    if (responseJson.Fault) {
        Logger.log("‚ùå API Error: " + JSON.stringify(responseJson.Fault));
    }
}


    }
  } catch (error) {
    Logger.log("‚ùå Error in updateInvoiceInQBO: " + error.message);
  }
}



function pushInvoiceToQBO(sheet) {
  checkRateLimit();

  try {
    Logger.log("üìå pushInvoiceToQBO Started for: " + sheet.getName());

    var invoiceNumber = sheet.getRange("A1").getValue().replace("Invoice Number: ", "").trim();
    var txnDate = sheet.getRange("A2").getValue().replace("Date: ", "").trim();
    var customer = sheet.getRange("A3").getValue().replace("Customer: ", "").trim();
    var total = parseFloat(sheet.getRange("A4").getValue().replace("Total: $", "").trim());

    Logger.log("üìÜ Date: " + txnDate);
    Logger.log("üë§ Customer: " + customer);
    Logger.log("üí∞ Total Before Recalculation: " + total);

    // **Step 1: Get All Invoice IDs and Sync Tokens**
    var invoiceId = getInvoiceIdByDocNumber(invoiceNumber);
    if (!invoiceId) {
      Logger.log("‚ùå No existing invoice found. Creating a new one instead.");
      createInvoiceInQBO(sheet);
      return;
    }

    var syncTokens = getAllSyncTokens([invoiceId]);  // Get SyncToken in batch
    var syncToken = syncTokens[invoiceId] || "0";  // Default to "0" if missing

    var invoiceData = {
      "Id": invoiceId,
      "SyncToken": syncToken,
      "DocNumber": invoiceNumber,
      "TxnDate": txnDate,
      "CustomerRef": { "name": customer },
      "TotalAmt": 0,
      "Line": []
    };

    Logger.log("üîÑ Collecting invoice line items...");

    var lastRow = sheet.getLastRow();
    var calculatedTotal = 0;

    for (var row = 7; row <= lastRow; row++) {
      var itemName = sheet.getRange("A" + row).getValue().trim();
      var qty = parseFloat(sheet.getRange("B" + row).getValue());
      var rate = parseFloat(sheet.getRange("C" + row).getValue());
      var amount = parseFloat(sheet.getRange("D" + row).getValue());
      var itemRef = sheet.getRange("E" + row).getValue();

      if (itemName && qty && rate && amount && itemRef) {
        Logger.log("üõí Item: " + itemName + " | Qty: " + qty + " | Rate: " + rate + " | Amount: " + amount + " | ItemRef: " + itemRef);

        invoiceData.Line.push({
          "DetailType": "SalesItemLineDetail",
          "Amount": amount,
          "Description": itemName,  // ‚úÖ Initially set to what‚Äôs in Google Sheets
          "SalesItemLineDetail": {
            "ItemRef": { "value": String(itemRef) },
            "Qty": qty,
            "UnitPrice": rate,
            "TaxCodeRef": { "value": "NON" }
          }
        });

        calculatedTotal += amount;
      }
    }

    invoiceData.TotalAmt = calculatedTotal;

    // ‚úÖ **Step 2: Fix Item Name Mismatches Before Sending**
    invoiceData.Line.forEach((line) => {
      if (line.SalesItemLineDetail) {
        var itemId = line.SalesItemLineDetail.ItemRef.value;
        var correctName = getItemNameById(itemId); // Fetch correct name from QuickBooks

        if (correctName) {
          Logger.log(`üîÑ Overwriting Description: ${line.Description} ‚Üí ${correctName}`);
          line.Description = correctName; // Ensure it matches QuickBooks data
        }
      }
    });

    Logger.log("üí∞ Final Calculated Total: " + invoiceData.TotalAmt);
    Logger.log("üì§ Sending Invoice Update (UPDATE): " + JSON.stringify(invoiceData));

    updateInvoiceInQBO(invoiceData);

  } catch (error) {
    Logger.log("‚ùå Error in pushInvoiceToQBO: " + error.message);
  }
}



function fetchWithRetry(url, options, maxRetries = 3) {
  let attempts = 0;
  let delay = 2000; // Start with 2 seconds

  while (attempts < maxRetries) {
    try {
      let response = UrlFetchApp.fetch(url, options);
      let statusCode = response.getResponseCode();

      if (statusCode === 200) {
        return response;  // ‚úÖ Success, return response
      } else if (statusCode === 429 || (statusCode >= 500 && statusCode < 600)) {
        // Handle 429 Rate Limit and 500+ Server Errors
        Logger.log(`‚ö†Ô∏è API Limit or Server Error (${statusCode}). Retrying in ${delay / 1000} seconds...`);
        Utilities.sleep(delay);
        delay *= 2; // ‚è≥ Exponential backoff
        attempts++;
      } else {
        Logger.log(`‚ùå API request failed with status: ${statusCode}`);
        return response;  // Return failed response for debugging
      }
    } catch (error) {
      Logger.log(`‚ùå Network Error: ${error.message}`);
      if (attempts < maxRetries - 1) {
        Logger.log(`üîÑ Retrying after ${delay / 1000} seconds...`);
        Utilities.sleep(delay);
        delay *= 2;  // Increase delay for next attempt
        attempts++;
      } else {
        return null;  // Return null if all retries fail
      }
    }
  }

  Logger.log("‚ùå Max retry limit reached for API request.");
  return null;  // Return null if all retries fail
}



function onEditTrigger(e) {
    var uniqueRunId = new Date().getTime(); // Unique timestamp for each execution
    Logger.log(`üîÑ New Execution ID: ${uniqueRunId}`);

    var lock = LockService.getScriptLock();
    if (!lock.tryLock(500)) {
        Logger.log(`‚õî Execution ID ${uniqueRunId} skipped due to active lock.`);
        return; // üî• If another instance is running, exit immediately
    }

    try {
        var sheet = e.source.getActiveSheet();
        var range = e.range;
        Logger.log(`üîÑ Execution ID ${uniqueRunId}: Triggered onEditTrigger for range: ${range.getA1Notation()} in sheet: ${sheet.getName()}`);

        // ‚úÖ Handle "Menu" sheet checkboxes
        if (sheet.getName() === "Menu" && (range.getA1Notation() === "A2" || range.getA1Notation() === "A3")) {
            var check1 = sheet.getRange("A2").getValue();
            var check2 = sheet.getRange("A3").getValue();
            if (check1 && check2) {
                Logger.log(`‚úÖ Execution ID ${uniqueRunId}: Both checkboxes checked in 'Menu'! Refreshing Invoices...`);
                refreshInvoices(); 
                sheet.getRange("A2").setValue(false);
                sheet.getRange("A3").setValue(false);
            }
        }

        // ‚úÖ Handle invoice sync checkboxes in invoice sheets
        if (range.getA1Notation() === "D2" || range.getA1Notation() === "D3") {
            var checkD2 = sheet.getRange("D2").getValue();
            var checkD3 = sheet.getRange("D3").getValue();
            if (checkD2 && checkD3) {
                var invoiceNumber = sheet.getRange("A1").getValue().replace("Invoice Number: ", "").trim();
                if (invoiceNumber) {
                    Logger.log(`‚úÖ Execution ID ${uniqueRunId}: Both checkboxes checked! Syncing Invoice: ${invoiceNumber}`);
                    pushInvoiceToQBO(sheet);
                    sheet.getRange("D2").setValue(false);
                    sheet.getRange("D3").setValue(false);
                } else {
                    Logger.log(`‚ùå Execution ID ${uniqueRunId}: No invoice number found in A1.`);
                }
            }
        }
    } catch (error) {
        Logger.log(`‚ùå Execution ID ${uniqueRunId}: Error in onEditTrigger: ${error.message}`);
    } finally {
        lock.releaseLock(); // üîì Ensure lock is always released
        Logger.log(`üîì Execution ID ${uniqueRunId} released lock.`);
    }
}


function createInstallableTrigger() {
  var triggers = ScriptApp.getProjectTriggers();
  
  // Avoid duplicate triggers
  for (var i = 0; i < triggers.length; i++) {
    if (triggers[i].getHandlerFunction() === "onEditTrigger") {
      Logger.log("üöÄ Installable trigger already exists!");
      return;
    }
  }
  
  ScriptApp.newTrigger("onEditTrigger")
    .forSpreadsheet(SpreadsheetApp.getActiveSpreadsheet())
    .onEdit()
    .create();
  
  Logger.log("‚úÖ Installable trigger created!");
}


/**
 * ‚úÖ Run this function once to set up the trigger!
 */
function setup() {
  createInstallableTrigger();
}






function encryptData(plainText) {
    return encryptWithKMS(plainText);
}

function decryptData(cipherText) {
    return decryptWithKMS(cipherText);
}


function getEncryptionKey() {
    return PropertiesService.getScriptProperties().getProperty("ENCRYPTION_KEY");
}


function getDecryptedRefreshToken() {
    var encryptedToken = PropertiesService.getScriptProperties().getProperty("ENCRYPTED_REFRESH_TOKEN");
    if (!encryptedToken) {
        Logger.log("‚ùå No encrypted refresh token found.");
        return null;
    }

    try {
        var decryptedToken = decryptWithKMS(encryptedToken);
        if (!decryptedToken) {
            Logger.log("‚ùå Decryption failed: Refresh token is invalid.");
            return null;
        }
        return decryptedToken;
    } catch (error) {
        Logger.log("‚ùå Error decrypting refresh token: " + error.message);
        return null;
    }
}




function clearStoredCredentials() {
    PropertiesService.getScriptProperties().deleteProperty("ENCRYPTED_CLIENT_ID");
    PropertiesService.getScriptProperties().deleteProperty("ENCRYPTED_CLIENT_SECRET");
    PropertiesService.getScriptProperties().deleteProperty("ENCRYPTED_REFRESH_TOKEN");
    Logger.log("üóëÔ∏è Cleared old encrypted credentials.");
}

function forceClearAllStoredProperties() {
    var scriptProperties = PropertiesService.getScriptProperties();
    
    scriptProperties.deleteProperty("ENCRYPTED_CLIENT_ID");
    scriptProperties.deleteProperty("ENCRYPTED_CLIENT_SECRET");
    scriptProperties.deleteProperty("ENCRYPTED_REFRESH_TOKEN");
    scriptProperties.deleteProperty("ENCRYPTION_KEY");  

    Logger.log("üóëÔ∏è Successfully deleted all stored properties.");
}



function testTokenEncryption() {
    var decryptedToken = getDecryptedRefreshToken();
    Logger.log("üîì Decrypted Refresh Token: " + decryptedToken);
}
function testRetrieveDecryptedToken() {
    var decryptedToken = getDecryptedRefreshToken();
    Logger.log("üîì Decrypted Token: " + decryptedToken);
}


function testTokenStorage() {
    var sampleToken = "Sample-Refresh-Token-123";  // Replace with an actual token
    storeRefreshToken(sampleToken);

    var retrievedToken = getDecryptedRefreshToken();
    Logger.log("üîì Decrypted Token: " + retrievedToken);
}


// üîπ Test the Encryption System
function testEncryption() {
    var originalData = "This is a secret message.";
    var encryptedData = encryptData(originalData);
    Logger.log("üîí Encrypted: " + encryptedData);

    var decryptedData = decryptData(encryptedData);
    Logger.log("üîì Decrypted: " + decryptedData);
}

function testDecryption() {
    var decryptedToken = getDecryptedRefreshToken();
    Logger.log("üîì Decrypted Refresh Token: " + decryptedToken);
}




function testStoreClientCredentials() {
    var clientId = "ABqPMA4he7LmUHvfyWkKgHMZRKbHuQmOf2J2ORLXI8NmbtPLnx";
    var clientSecret = "yHSoWulZ6Bfia8d5UZ3nuOj2NrgPEK8X0sL5Qvst";

    var encryptedClientId = encryptData(clientId);
    var encryptedClientSecret = encryptData(clientSecret);

    PropertiesService.getScriptProperties().setProperty("ENCRYPTED_CLIENT_ID", encryptedClientId);
    PropertiesService.getScriptProperties().setProperty("ENCRYPTED_CLIENT_SECRET", encryptedClientSecret);

    Logger.log("‚úÖ Encrypted client credentials stored securely.");
}

function testRetrieveEncryptedCredentials() {
    var encryptedClientId = PropertiesService.getScriptProperties().getProperty("ENCRYPTED_CLIENT_ID");
    var encryptedClientSecret = PropertiesService.getScriptProperties().getProperty("ENCRYPTED_CLIENT_SECRET");
    Logger.log("üîê Stored ENCRYPTED_CLIENT_ID: " + encryptedClientId);
    Logger.log("üîê Stored ENCRYPTED_CLIENT_SECRET: " + encryptedClientSecret);
}

function testRetrieveDecryptedCredentials() {
    var credentials = getDecryptedClientCredentials();
    if (!credentials) {
        Logger.log("‚ùå Failed to retrieve credentials.");
    } else {
        Logger.log("üîì Decrypted Client ID: " + credentials.clientId);
        Logger.log("üîì Decrypted Client Secret: " + credentials.clientSecret);
    }
}

function checkStoredCredentials() {
    var clientId = PropertiesService.getScriptProperties().getProperty("ENCRYPTED_CLIENT_ID");
    var clientSecret = PropertiesService.getScriptProperties().getProperty("ENCRYPTED_CLIENT_SECRET");
    var refreshToken = PropertiesService.getScriptProperties().getProperty("ENCRYPTED_REFRESH_TOKEN");

    if (!clientId || !clientSecret || !refreshToken) {
        Logger.log("‚ùå Missing stored credentials.");
    } else {
        Logger.log("‚úÖ Credentials are stored.");
    }
}



function testBaseURL() {
    const accessToken = getAccessToken();
    if (!accessToken) {
        Logger.log("‚ùå No access token retrieved.");
        return;
    }

    const testUrl = BASE_URL + COMPANY_ID + "/companyinfo/" + COMPANY_ID;
    const headers = { "Authorization": "Bearer " + accessToken, "Accept": "application/json" };

    const options = { method: "get", headers: headers, muteHttpExceptions: true };

    const response = fetchWithRetry(testUrl, options);
    Logger.log("‚úÖ QuickBooks API Response: " + response.getContentText());
}




function authorizeExternalRequests() {
  fetchWithRetry("https://www.google.com");
  Logger.log("‚úÖ External requests authorized.");
}



function testPushInvoice() {
  var sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("Inv_1032"); // Change to the name of an actual invoice tab
  if (sheet) {
    pushInvoiceToQBO(sheet);
  } else {
    Logger.log("‚ùå Error: Invoice sheet not found.");
  }
}


function testEncryption() {
    var passphrase = '0nofFCM8RE4KrUKSHG-oTiOcoOItxm1Fao1GWhLV-2s';
    var originalText = 'Sensitive data to encrypt';

    // Encrypt the data
    var encryptedText = encryptData(originalText, passphrase);
    Logger.log('Encrypted Text: ' + encryptedText);

    // Decrypt the data
    var decryptedText = decryptData(encryptedText, passphrase);
    Logger.log('Decrypted Text: ' + decryptedText);
}





function testKMS() {
    var secret = "My Super Secret Data!";
    Logger.log("Original: " + secret);

    var encrypted = encryptData(secret);
    Logger.log("üîí Encrypted: " + encrypted);

    var decrypted = decryptData(encrypted);
    Logger.log("üîì Decrypted: " + decrypted);
}



function testAccessToken() {
    var token = getAccessToken();
    Logger.log("Access Token: " + token);
}

function manuallySetRefreshToken() {
    var newToken = "AB11748233035STQx3cOVsadkGuJ26QB9APntsQaB2UKSK9Seo"; // ‚¨ÖÔ∏è Paste the refresh token you got
    storeRefreshToken(newToken);
    Logger.log("‚úÖ New refresh token securely stored.");
}



function testAccessTokenManually() {
    var accessToken = getAccessToken();
    if (!accessToken) {
        Logger.log("‚ùå No access token retrieved.");
        return;
    }

    var testUrl = "https://quickbooks.api.intuit.com/v3/company/9341452081841163/companyinfo/9341452081841163";
    var headers = {
        "Authorization": "Bearer " + accessToken,
        "Accept": "application/json"
    };
    Logger.log("üîê Sending Request to QuickBooks with Token: " + accessToken);

    var options = {
        method: "get",
        headers: headers,
        muteHttpExceptions: true
    };

    var response = UrlFetchApp.fetch(testUrl, options);
    Logger.log("‚úÖ Manual API Response: " + response.getContentText());
}




function storeClientCredentialsManually() {
    var clientId = "ABqPMA4he7LmUHvfyWkKgHMZRKbHuQmOf2J2ORLXI8NmbtPLnx";  
    var clientSecret = "yHSoWulZ6Bfia8d5UZ3nuOj2NrgPEK8X0sL5Qvst";  
    var refreshToken = "BB11747439614knG8CF3iQtMbBbvy3FBEvIsT9Si4MPAdj2U5f";  

    PropertiesService.getScriptProperties().setProperty("ENCRYPTED_CLIENT_ID", encryptWithKMS(clientId));
    PropertiesService.getScriptProperties().setProperty("ENCRYPTED_CLIENT_SECRET", encryptWithKMS(clientSecret));
    PropertiesService.getScriptProperties().setProperty("ENCRYPTED_REFRESH_TOKEN", encryptWithKMS(refreshToken));

    Logger.log("‚úÖ QuickBooks credentials securely stored.");
}






function testDecryptedClientCredentials() {
    var credentials = getDecryptedClientCredentials();
    if (!credentials) {
        Logger.log("‚ùå No credentials retrieved.");
    } else {
        Logger.log("üîì Decrypted CLIENT_ID: " + credentials.CLIENT_ID);
        Logger.log("üîì Decrypted CLIENT_SECRET: " + credentials.CLIENT_SECRET);
    }
}
function testRetrieveDecryptedToken() {
    var decryptedToken = getDecryptedRefreshToken();
    Logger.log("üîì Decrypted Token: " + decryptedToken);
}


function testAccessToken() {
    var token = getAccessToken();
    Logger.log("üîë Access Token: " + token);
}



function testAccessTokenScopes() {
    var accessToken = getAccessToken();
    if (!accessToken) {
        Logger.log("‚ùå No access token retrieved.");
        return;
    }

    var testUrl = `https://sandbox-quickbooks.api.intuit.com/v3/company/${COMPANY_ID}/companyinfo/${COMPANY_ID}`;
    var headers = {
        "Authorization": "Bearer " + accessToken,
        "Accept": "application/json"
    };

    var options = {
        method: "get",
        headers: headers,
        muteHttpExceptions: true
    };

    var response = UrlFetchApp.fetch(testUrl, options);
    Logger.log("‚úÖ Token Info Response: " + response.getContentText());
}



function testSecretManagerAccess() {
    var url = "https://secretmanager.googleapis.com/v1/projects/291507329802/secrets";
    var options = {
        method: "get",
        headers: {
            "Authorization": "Bearer " + ScriptApp.getOAuthToken(),
            "Content-Type": "application/json"
        }
    };
    var response = UrlFetchApp.fetch(url, options);
    Logger.log("Response: " + response.getContentText());
}


