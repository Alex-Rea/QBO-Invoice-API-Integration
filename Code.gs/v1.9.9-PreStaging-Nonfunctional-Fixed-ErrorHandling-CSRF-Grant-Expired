var requestCount = 0;
var scriptProperties = PropertiesService.getScriptProperties();

// üåê Cloud KMS Config
const PROJECT_ID = "qbo-api-invoice-integration";
const LOCATION_ID = "global"; // Change if using a specific region
const KEY_RING_ID = "my-key-ring";
const KEY_ID = "my-encryption-key";
const BASE_URL = "https://quickbooks.api.intuit.com/v3/company/";
const COMPANY_ID = PropertiesService.getScriptProperties().getProperty("COMPANY_ID");


// üõ† Cached Auth Tokens
var lastKmsToken = null;
var lastKmsTokenTime = null;
var lastAccessToken = null;
var lastTokenTime = null;

// üîê Fetch Secret from Google Secret Manager
function getSecretFromSecretManager(secretName) {
  const url = `https://secretmanager.googleapis.com/v1/projects/${PROJECT_ID}/secrets/${secretName}/versions/latest:access`;

  const options = {
    method: "get",
    headers: {
      Authorization: `Bearer ${ScriptApp.getOAuthToken()}`,
      Accept: "application/json"
    },
    muteHttpExceptions: true
  };

  const response = UrlFetchApp.fetch(url, options);
  const json = JSON.parse(response.getContentText());

  if (response.getResponseCode() === 200 && json.payload && json.payload.data) {
    return Utilities.newBlob(Utilities.base64Decode(json.payload.data)).getDataAsString();
  } else {
    Logger.log(`‚ùå Error retrieving secret '${secretName}': ${response.getContentText()}`);
    return null;
  }
}

// üîë Get OAuth Token for Cloud KMS
function getAuthToken() {
  const now = new Date().getTime();
  if (lastKmsToken && now - lastKmsTokenTime < 3600000) {
    Logger.log("‚úÖ Using cached Cloud KMS Auth Token.");
    return lastKmsToken;
  }

  const secretJson = getSecretFromSecretManager("SERVICE_ACCOUNT_JSON");
  if (!secretJson) {
    Logger.log("‚ùå Failed to retrieve service account JSON from Secret Manager.");
    return null;
  }

  const credentials = JSON.parse(secretJson);
  const tokenResponse = UrlFetchApp.fetch("https://oauth2.googleapis.com/token", {
    method: "post",
    contentType: "application/json",
    payload: JSON.stringify({
      grant_type: "urn:ietf:params:oauth:grant-type:jwt-bearer",
      assertion: createJwt(credentials)
    })
  });

  const response = JSON.parse(tokenResponse.getContentText());
  if (response.access_token) {
    lastKmsToken = response.access_token;
    lastKmsTokenTime = now;
    return lastKmsToken;
  }

  Logger.log("‚ùå Failed to get Cloud KMS Auth Token.");
  return null;
}

// üîê Create JWT for Cloud KMS Authentication
function createJwt(credentials) {
    var now = Math.floor(Date.now() / 1000);
    var payload = {
        iss: credentials.client_email,
        scope: "https://www.googleapis.com/auth/cloudkms",
        aud: "https://oauth2.googleapis.com/token",
        exp: now + 3600,
        iat: now
    };

    var encodedHeader = Utilities.base64EncodeWebSafe(JSON.stringify({ alg: "RS256", typ: "JWT" }));
    var encodedPayload = Utilities.base64EncodeWebSafe(JSON.stringify(payload));
    var signatureInput = encodedHeader + "." + encodedPayload;
    var signature = Utilities.computeRsaSha256Signature(signatureInput, credentials.private_key);
    return signatureInput + "." + Utilities.base64EncodeWebSafe(signature);
}


// üîí Encrypt Data with Cloud KMS (Optimized)
function encryptWithKMS(plainText) {
    if (!lastKmsToken) lastKmsToken = getAuthToken(); // Only fetch if missing

    var url = `https://cloudkms.googleapis.com/v1/projects/${PROJECT_ID}/locations/${LOCATION_ID}/keyRings/${KEY_RING_ID}/cryptoKeys/${KEY_ID}:encrypt`;
    var requestBody = { plaintext: Utilities.base64Encode(plainText) };

    var response = UrlFetchApp.fetch(url, {
        method: "post",
        headers: { Authorization: `Bearer ${lastKmsToken}`, "Content-Type": "application/json" },
        payload: JSON.stringify(requestBody)
    });

    return JSON.parse(response.getContentText()).ciphertext;
}

// üîì Decrypt Data with Cloud KMS (Optimized)
function decryptWithKMS(encryptedText) {
    if (!lastKmsToken) lastKmsToken = getAuthToken(); // Only fetch if missing

    var url = `https://cloudkms.googleapis.com/v1/projects/${PROJECT_ID}/locations/${LOCATION_ID}/keyRings/${KEY_RING_ID}/cryptoKeys/${KEY_ID}:decrypt`;
    var requestBody = { ciphertext: encryptedText };

    var response = UrlFetchApp.fetch(url, {
        method: "post",
        headers: { Authorization: `Bearer ${lastKmsToken}`, "Content-Type": "application/json" },
        payload: JSON.stringify(requestBody)
    });

    return Utilities.newBlob(
        Utilities.base64Decode(JSON.parse(response.getContentText()).plaintext)
    ).getDataAsString();
}


// üîë Retrieve and Decrypt QuickBooks Credentials
function getDecryptedClientCredentials() {
    var encryptedClientId = PropertiesService.getScriptProperties().getProperty("ENCRYPTED_CLIENT_ID");
    var encryptedClientSecret = PropertiesService.getScriptProperties().getProperty("ENCRYPTED_CLIENT_SECRET");

    if (!encryptedClientId || !encryptedClientSecret) {
        Logger.log("‚ùå No stored credentials found.");
        return null;
    }

    return {
        CLIENT_ID: decryptWithKMS(encryptedClientId),
        CLIENT_SECRET: decryptWithKMS(encryptedClientSecret)
    };
}


// üîë Get QuickBooks Access Token with Expiration & Refresh Token Handling
function getAccessToken() {
  checkRateLimit();  // üõ° Prevent hitting rate limits

  const now = new Date().getTime();
  if (lastAccessToken && now - lastTokenTime < 3600000) {
    Logger.log("‚úÖ Using Cached Access Token.");
    return lastAccessToken;
  }

  const service = getOAuthService();
  if (!service.hasAccess()) {
    Logger.log("‚ùå Access token expired or invalid. Attempting to refresh token...");

    // üîÑ Automatically refresh the token if it‚Äôs expired
    if (!service.refresh()) {
      Logger.log("‚ùå Refresh token expired or invalid. User re-authorization required.");
      promptReauthorization();
      return null;
    }
  }

  const accessToken = service.getAccessToken();
  lastAccessToken = accessToken;
  lastTokenTime = now;

  Logger.log("üîë Access Token Retrieved: " + maskToken(accessToken));
  return accessToken;
}

// üîÑ Trigger reauthorization prompt if refresh token fails
function promptReauthorization() {
  Logger.log("üîÑ Access token expired. Re-authorization required.");
  const service = getOAuthService();
  const authorizationUrl = service.getAuthorizationUrl();
  Logger.log('üìå Please reauthorize the app: ' + authorizationUrl);
}

// üîí Mask sensitive information in logs
function maskToken(token) {
  return token ? token.substring(0, 4) + "****" + token.slice(-4) : null;
}

// üîê Set up OAuth 2.0 Service
function getOAuthService() {
  const credentials = getDecryptedClientCredentials();  // Securely decrypt stored credentials

  return OAuth2.createService('QuickBooks')
    .setAuthorizationBaseUrl('https://appcenter.intuit.com/connect/oauth2')
    .setTokenUrl('https://oauth.platform.intuit.com/oauth2/v1/tokens/bearer')
    .setClientId(credentials.CLIENT_ID)
    .setClientSecret(credentials.CLIENT_SECRET)
    .setCallbackFunction('authCallback')
    .setPropertyStore(PropertiesService.getScriptProperties())
    .setScope('com.intuit.quickbooks.accounting')
    .setTokenHeaders({
      'Accept': 'application/json'
    })
    .setParam('response_type', 'code')
    .setParam('redirect_uri', `https://script.google.com/macros/d/${ScriptApp.getScriptId()}/usercallback`);
}

// üîÑ Handle OAuth callback from Intuit
function authCallback(request) {
  const service = getOAuthService();
  const authorized = service.handleCallback(request);

  if (authorized) {
    Logger.log("‚úÖ Successfully authorized.");
    return HtmlService.createHtmlOutput('Authorization successful! You can close this tab.');
  } else {
    // üîç Check if it's due to an invalid grant or expired token
    const error = request.parameter.error;
    
    if (error === 'invalid_grant') {
      Logger.log("‚ùå Invalid grant error detected. Token may have expired or been revoked.");
      return HtmlService.createHtmlOutput('Authorization failed due to invalid grant. Please reauthorize.');
    }

    if (error === 'csrf') {
      Logger.log("‚ùå CSRF error detected. Possible unauthorized request attempt.");
      return HtmlService.createHtmlOutput('Security error detected (CSRF). Please try again or contact support.');
    }

    Logger.log("‚ùå Authorization denied or unknown error: " + JSON.stringify(request.parameter));
    return HtmlService.createHtmlOutput('Authorization denied or an unknown error occurred.');
  }
}


function isXmlResponse(responseText) {
  return responseText.trim().startsWith("<?xml");
}


// üîë Retrieve & Decrypt QuickBooks Credentials
function getDecryptedClientCredentials() {
    var encryptedClientId = PropertiesService.getScriptProperties().getProperty("ENCRYPTED_CLIENT_ID");
    var encryptedClientSecret = PropertiesService.getScriptProperties().getProperty("ENCRYPTED_CLIENT_SECRET");

    if (!encryptedClientId || !encryptedClientSecret) return Logger.log("‚ùå No stored credentials found.");

    return {
        CLIENT_ID: decryptWithKMS(encryptedClientId),
        CLIENT_SECRET: decryptWithKMS(encryptedClientSecret)
    };
}



function checkRateLimit() {
  requestCount++;
  if (requestCount % 5 === 0) {  // Every 5 requests, wait 1.5 seconds
    Logger.log("‚è≥ Adding delay to prevent hitting QuickBooks rate limits...");
    Utilities.sleep(1500);
  }
}


function refreshInvoices() {
  checkRateLimit();

  var ss = SpreadsheetApp.openById('17V9u1Bz0LM0xOPz3AayXcRh4xIvYnRamfb2x3f9O7Z8');
  var menuSheet = ss.getSheetByName("Menu");

  if (!menuSheet) {
    Logger.log("‚ùå Error: 'Menu' sheet not found.");
    return;
  }

  // ‚úÖ Step 1: Check if A2 and A3 are both checked
  var checkA2 = menuSheet.getRange("A2").getValue();
  var checkA3 = menuSheet.getRange("A3").getValue();

  if (!(checkA2 && checkA3)) {
    Logger.log("‚ùå A2 and A3 must be checked to refresh invoices.");
    return;
  }

  Logger.log("‚úÖ Both checkboxes checked in 'Menu'! Refreshing Invoices...");

  // ‚úÖ Step 2: Delete all existing invoice sheets
  var sheets = ss.getSheets();
  var invoiceSheets = sheets.filter(sheet => sheet.getName().startsWith("Inv_"));
  Logger.log("üóë Found " + invoiceSheets.length + " invoice sheets to delete.");

  invoiceSheets.forEach(sheet => {
    try {
      ss.deleteSheet(sheet);
      Logger.log("üóë Deleted: " + sheet.getName());
    } catch (e) {
      Logger.log("‚ö†Ô∏è Skipping already deleted sheet: " + e.message);
    }
  });

  // ‚úÖ Step 3: Fetch new invoices from QuickBooks
  var accessToken = getAccessToken();
  if (!accessToken) {
    Logger.log("‚ùå No access token retrieved!");
    return;
  }

  var query = "SELECT * FROM Invoice ORDERBY TxnDate DESC STARTPOSITION 1 MAXRESULTS 10";
  var apiUrl = BASE_URL + COMPANY_ID + "/query?query=" + encodeURIComponent(query);

  var headers = {
    "Authorization": "Bearer " + accessToken,
    "Accept": "application/json"
  };

  var options = {
    method: "get",
    headers: headers,
    muteHttpExceptions: true
  };

  var response = fetchWithRetry(apiUrl, options);
  var json = JSON.parse(response.getContentText());

  if (json.Fault) {
    Logger.log("‚ùå API Error: " + JSON.stringify(json.Fault));
    return;
  }

  if (!json.QueryResponse || !json.QueryResponse.Invoice) {
    Logger.log("‚ö†Ô∏è No invoices found in QuickBooks!");
    return;
  }

  var invoices = json.QueryResponse.Invoice;
  Logger.log("‚úÖ Invoices Retrieved: " + invoices.length);

// ‚úÖ Step 4: Create new invoice sheets & store links with `gid`
var invoiceLinks = [];
var invoiceDescriptions = [];

invoices.forEach(function(invoice) {
  var invoiceNumber = invoice.DocNumber || "Invoice_" + invoice.Id;
  var invoiceTabName = "Inv_" + invoiceNumber;
  var customerName = invoice.CustomerRef && invoice.CustomerRef.name ? invoice.CustomerRef.name : "Unknown Customer";

  var newSheet = ss.insertSheet(invoiceTabName);
  formatInvoiceSheet(newSheet, invoice);

  // ‚úÖ Use `gid` for links
  var sheetGid = newSheet.getSheetId();
  var linkFormula = `=HYPERLINK("https://docs.google.com/spreadsheets/d/${ss.getId()}/edit#gid=${sheetGid}", "${invoiceNumber}")`;
  
  invoiceLinks.push([linkFormula]);         // Column A (Invoice Links)
  invoiceDescriptions.push([customerName]); // Column B (Customer Name)
});

// ‚úÖ Place links in "Menu" (A5:A10) & customer names in (B5:B10)
var menuSheet = ss.getSheetByName("Menu");
var linkRange = menuSheet.getRange(5, 1, invoiceLinks.length, 1);
var descRange = menuSheet.getRange(5, 2, invoiceDescriptions.length, 1);

linkRange.setFormulas(invoiceLinks);
descRange.setValues(invoiceDescriptions);



  // ‚úÖ Step 6: Reset A2 & A3 checkboxes
  menuSheet.getRange("A2").setValue(false);
  menuSheet.getRange("A3").setValue(false);

  Logger.log("‚úÖ Invoice refresh complete!");
}




function formatInvoiceSheet(newSheet, invoice) {
  newSheet.getRange("A1").setValue("Invoice Number: " + (invoice.DocNumber || "N/A"));
  newSheet.getRange("A2").setValue("Date: " + (invoice.TxnDate || "N/A"));
  newSheet.getRange("A3").setValue("Customer: " + (invoice.CustomerRef ? invoice.CustomerRef.name : "Unknown"));
  
  // ‚úÖ Auto-updating total
  newSheet.getRange("A4").setFormula('="Total: $" & SUM(D7:D)');

  newSheet.getRange("A6").setValue("Item");
  newSheet.getRange("B6").setValue("Quantity");
  newSheet.getRange("C6").setValue("Rate");
  newSheet.getRange("D6").setValue("Amount");
  newSheet.getRange("E6").setValue("ItemRef"); // Store ItemRef for QBO

var row = 7;

  if (invoice.Line && invoice.Line.length > 0) {
    invoice.Line.forEach(function(line) {
      if (line.SalesItemLineDetail) {
        var itemRef = line.SalesItemLineDetail.ItemRef ? line.SalesItemLineDetail.ItemRef.value : "N/A";
        
        // ‚úÖ **Extract the actual Item Name instead of Sales Description**
        var itemName = (itemRef && itemRef !== "N/A") ? getItemNameById(itemRef) : "Unknown";
        newSheet.getRange("A" + row).setValue(itemName);
        newSheet.getRange("B" + row).setValue(line.SalesItemLineDetail.Qty || 0);
        newSheet.getRange("C" + row).setValue(line.SalesItemLineDetail.UnitPrice || 0);
        newSheet.getRange("D" + row).setFormula("=B" + row + "*C" + row);
        newSheet.getRange("E" + row).setValue(itemRef); // Store ItemRef

        row++;
      }
    });
  } else {
    newSheet.getRange("A7").setValue("‚ö†Ô∏è No items found for this invoice.");
  }

  newSheet.getRange("D1").setValue("Push Changes");
  newSheet.getRange("D2").insertCheckboxes();
  newSheet.getRange("D3").insertCheckboxes();
}


function getAllSyncTokens(invoiceIds) {
  if (!invoiceIds.length) {
    return {};
  }

  checkRateLimit();

  const accessToken = getAccessToken();
  if (!accessToken) {
    Logger.log("‚ùå No access token, cannot fetch SyncTokens.");
    return {};
  }
  Logger.log("üîë Using Access Token: " + maskToken(accessToken));

  const query = "SELECT Id, SyncToken FROM Invoice WHERE Id IN (" + invoiceIds.map(id => `'${id}'`).join(",") + ")";
  const apiUrl = BASE_URL + COMPANY_ID + "/query?query=" + encodeURIComponent(query);

  const headers = {
    "Authorization": "Bearer " + accessToken,
    "Accept": "application/json"
  };

  const options = {
    method: "get",
    headers: headers,
    muteHttpExceptions: true
  };

  const response = fetchWithRetry(apiUrl, options);
  const json = JSON.parse(response.getContentText());

  let syncTokenMap = {};
  if (json.QueryResponse && json.QueryResponse.Invoice) {
    json.QueryResponse.Invoice.forEach(invoice => {
      syncTokenMap[invoice.Id] = invoice.SyncToken;
    });
    Logger.log("‚úÖ Retrieved SyncTokens for " + json.QueryResponse.Invoice.length + " invoices.");
  } else {
    Logger.log("‚ùå Failed to retrieve SyncTokens.");
  }

  return syncTokenMap;
}

function getInvoiceByDocNumber(docNumber) {
  checkRateLimit();

  try {
    const accessToken = getAccessToken();
    if (!accessToken) {
      Logger.log("‚ùå No access token, cannot retrieve invoice.");
      return null;
    }

    const query = "SELECT Id, SyncToken, CustomerRef FROM Invoice WHERE DocNumber = '" + docNumber + "'";
    const apiUrl = BASE_URL + COMPANY_ID + "/query?query=" + encodeURIComponent(query);

    const headers = {
      "Authorization": "Bearer " + accessToken,
      "Accept": "application/json"
    };

    const options = {
      method: "get",
      headers: headers,
      muteHttpExceptions: true
    };

    const response = fetchWithRetry(apiUrl, options);
    const json = JSON.parse(response.getContentText());

    if (json.QueryResponse && json.QueryResponse.Invoice && json.QueryResponse.Invoice.length > 0) {
      const invoice = json.QueryResponse.Invoice[0];

      Logger.log("‚úÖ Invoice found: " + JSON.stringify(invoice)); // üîÑ Keep logging for debugging

      if (!invoice.Id || !invoice.SyncToken) {
        Logger.log("‚ö†Ô∏è Invoice data is missing critical fields (Id/SyncToken).");
        return null;
      }

      return invoice;
    } else {
      Logger.log("‚ùå Invoice not found for DocNumber: " + docNumber);
      return null;
    }

  } catch (error) {  // ‚úÖ Missing catch block added here!
    Logger.log("‚ùå Error in getInvoiceByDocNumber: " + error.message);
    return null;
  }
}


function getInvoiceIdByDocNumber(docNumber) {
  checkRateLimit();

  const accessToken = getAccessToken();
  if (!accessToken) {
    Logger.log("‚ùå No access token, cannot fetch invoice ID.");
    return null;
  }

  const query = "SELECT Id FROM Invoice WHERE DocNumber = '" + docNumber + "'";
  const apiUrl = BASE_URL + COMPANY_ID + "/query?query=" + encodeURIComponent(query);

  const headers = {
    "Authorization": "Bearer " + accessToken,
    "Accept": "application/json"
  };

  const options = {
    method: "get",
    headers: headers,
    muteHttpExceptions: true
  };

  const response = fetchWithRetry(apiUrl, options);
  const json = JSON.parse(response.getContentText());

  if (json.QueryResponse && json.QueryResponse.Invoice && json.QueryResponse.Invoice.length > 0) {
    Logger.log("‚úÖ Invoice found: " + JSON.stringify(json.QueryResponse.Invoice[0]));
    return json.QueryResponse.Invoice[0].Id;
  } else {
    Logger.log("‚ùå No existing invoice found for DocNumber: " + docNumber);
    return null;
  }
}


function getItemNameById(itemId) {
  checkRateLimit();

  if (!itemId || itemId === "N/A") {
    Logger.log("‚ö†Ô∏è Skipping item lookup: No valid item ID.");
    return null;
  }
  Utilities.sleep(1000);  // ‚úÖ 1-second delay to prevent rate limiting

  const accessToken = getAccessToken();
  if (!accessToken) {
    Logger.log("‚ùå No access token, cannot fetch item name.");
    return null;
  }

  const query = "SELECT Name FROM Item WHERE Id = '" + itemId + "'";
  const apiUrl = BASE_URL + COMPANY_ID + "/query?query=" + encodeURIComponent(query);

  const headers = {
    "Authorization": "Bearer " + accessToken,
    "Accept": "application/json"
  };

  const options = {
    method: "get",
    headers: headers,
    muteHttpExceptions: true
  };

  const response = fetchWithRetry(apiUrl, options);
  const json = JSON.parse(response.getContentText());

  if (json.QueryResponse && json.QueryResponse.Item && json.QueryResponse.Item.length > 0) {
    Logger.log("‚úÖ Item Found: " + JSON.stringify(json.QueryResponse.Item[0]));
    return json.QueryResponse.Item[0].Name;
  } else {
    Logger.log("‚ùå Item ID not found in QuickBooks: " + itemId);
    return null;
  }
}

function getCustomerIdByName(customerName) {
  if (!customerName) {
    Logger.log("‚ùå No customer name provided.");
    return null;
  }

  // ‚úÖ Use cached data if available
  if (customerCache[customerId]) {
    return customerCache[customerId].email;
  }

  const accessToken = getAccessToken();
  if (!accessToken) {
    Logger.log("‚ùå No access token, cannot fetch customer.");
    return null;
  }

const query = "SELECT Id, DisplayName FROM Customer WHERE DisplayName = '" + customerName + "'";
  const apiUrl = BASE_URL + COMPANY_ID + "/query?query=" + encodeURIComponent(query);

  const headers = {
    "Authorization": "Bearer " + accessToken,
    "Accept": "application/json"
  };

  const options = {
    method: "get",
    headers: headers,
    muteHttpExceptions: true
  };

  const response = fetchWithRetry(apiUrl, options);
  const json = JSON.parse(response.getContentText());

  if (json.Customer && json.Customer.PrimaryEmailAddr) {
    const email = json.Customer.PrimaryEmailAddr.Address;
    customerCache[customerId] = { email: email };  // ‚úÖ Cache the email
    Logger.log("‚úÖ Customer email found: " + email);
    return email;
  } else {
    Logger.log("‚ö†Ô∏è No email found for Customer ID: " + customerId);
    return null;
  }
}


function getItemRefByName(itemName) {
  checkRateLimit();

  const accessToken = getAccessToken();
  if (!accessToken) {
    Logger.log("‚ùå No access token, cannot fetch item.");
    return null;
  }

  const query = "SELECT Id, Name FROM Item WHERE Name = '" + itemName + "'";
  const apiUrl = BASE_URL + COMPANY_ID + "/query?query=" + encodeURIComponent(query);

  const headers = {
    "Authorization": "Bearer " + accessToken,
    "Accept": "application/json"
  };

  const options = {
    method: "get",
    headers: headers,
    muteHttpExceptions: true
  };

  const response = fetchWithRetry(apiUrl, options);
  const json = JSON.parse(response.getContentText());

  if (json.QueryResponse && json.QueryResponse.Item && json.QueryResponse.Item.length > 0) {
    Logger.log("‚úÖ Item found: " + JSON.stringify(json.QueryResponse.Item[0]));
    return {
      value: json.QueryResponse.Item[0].Id,
      name: json.QueryResponse.Item[0].Name
    };
  } else {
    Logger.log("‚ùå Item not found in QuickBooks: " + itemName);
    return null;
  }
}

var customerCache = {};  // ‚úÖ Store customer details in memory

function getCustomerEmailById(customerId) {
  checkRateLimit();

  if (!customerId) {
    Logger.log("‚ùå No customer ID provided.");
    return null;
  }

  // ‚úÖ Return from cache if available
  if (customerCache[customerId]) {
    return customerCache[customerId].email;
  }

  const accessToken = getAccessToken();
  if (!accessToken) {
    Logger.log("‚ùå No access token, cannot fetch customer email.");
    return null;
  }

  const apiUrl = BASE_URL + COMPANY_ID + "/customer/" + customerId;

  const headers = {
    "Authorization": "Bearer " + accessToken,
    "Accept": "application/json"
  };

  const options = {
    method: "get",
    headers: headers,
    muteHttpExceptions: true
  };

  const response = fetchWithRetry(apiUrl, options);
  const json = JSON.parse(response.getContentText());

  if (json.Customer && json.Customer.PrimaryEmailAddr) {
    const email = json.Customer.PrimaryEmailAddr.Address;
    customerCache[customerId] = { email: email };  // ‚úÖ Cache the email
    Logger.log("‚úÖ Customer email found: " + email);
    return email;
  } else {
    Logger.log("‚ö†Ô∏è No email found for Customer ID: " + customerId);
    return null;
  }
}



function updateInvoiceInQBO(invoiceData) {
  checkRateLimit();

  try {
    const accessToken = getAccessToken();
    if (!accessToken) {
      Logger.log("‚ùå No access token, cannot update invoice.");
      return;
    }

    // ‚úÖ Fetch existing invoice details to get SyncToken, Customer ID, and Email
    const existingInvoice = getInvoiceByDocNumber(invoiceData.DocNumber);
    if (!existingInvoice || !existingInvoice.Id || !existingInvoice.SyncToken) {
      Logger.log("‚ùå Could not retrieve invoice details for updating.");
      return;
    }

    // ‚úÖ Preserve critical fields (Customer ID, SyncToken, Email)
    invoiceData.Id = existingInvoice.Id;
    invoiceData.SyncToken = existingInvoice.SyncToken;
    invoiceData.CustomerRef = { "value": existingInvoice.CustomerRef.value }; // Ensure correct Customer ID

    // ‚úÖ Preserve BillEmail if it exists
    if (existingInvoice.BillEmail && existingInvoice.BillEmail.Address) {
      invoiceData.BillEmail = { "Address": existingInvoice.BillEmail.Address };
      Logger.log("üìß Preserved Email: " + existingInvoice.BillEmail.Address);
    } else {
      // ‚úÖ Fetch email from customer profile if missing
      const customerEmail = getCustomerEmailById(existingInvoice.CustomerRef.value);
      if (customerEmail) {
        invoiceData.BillEmail = { "Address": customerEmail };
        Logger.log("üìß Retrieved Customer Email: " + customerEmail);
      } else {
        Logger.log("‚ö†Ô∏è No email found, skipping BillEmail field.");
      }
    }

    // ‚úÖ Ensure line items have correct calculations
    invoiceData.Line.forEach((line) => {
      if (line.SalesItemLineDetail) {
        var unitPrice = parseFloat(line.SalesItemLineDetail.UnitPrice);
        var qty = parseFloat(line.SalesItemLineDetail.Qty);

        // ‚úÖ Ensure Amount is correctly calculated to avoid QuickBooks 6070 Error
        line.Amount = parseFloat((unitPrice * qty).toFixed(2));

        // ‚úÖ Ensure Tax Code is set
        line.SalesItemLineDetail.TaxCodeRef = { "value": "NON" };
      }
    });

    const apiUrl = BASE_URL + COMPANY_ID + "/invoice";

    const headers = {
      "Authorization": "Bearer " + accessToken,
      "Accept": "application/json",
      "Content-Type": "application/json"
    };

    const payload = JSON.stringify(invoiceData);
    Logger.log("üì§ Sending Invoice Update (UPDATE): " + payload);

    const options = {
      method: "post",
      headers: headers,
      muteHttpExceptions: true,
      payload: payload
    };

    let response = fetchWithRetry(apiUrl, options);
    let responseJson = JSON.parse(response.getContentText());

    if (response.getResponseCode() === 200) {
      Logger.log("‚úÖ QuickBooks API Update Successful!");
      return;
    } 
    
    // ‚úÖ Handle API Errors
    else if (responseJson.Fault && responseJson.Fault.Error) {
      let errorCode = responseJson.Fault.Error[0].code;

      // ‚úÖ Ensure retryCount is properly initialized
      if (typeof invoiceData.retryCount === "undefined") {
        invoiceData.retryCount = 0; // Initialize retry count only once
      }

if (errorCode === "5010" && invoiceData.retryCount < 3) { // üõë Stale Object Error
    Logger.log("‚ö†Ô∏è Stale Object Error Detected! Fetching latest SyncToken...");

    const syncTokens = getAllSyncTokens([invoiceData.Id]); // Fetch in batch
    let latestSyncToken = syncTokens[invoiceData.Id];

    if (!latestSyncToken) {
        Logger.log("‚ùå Failed to fetch the latest SyncToken. Update aborted.");
        return;
    }

    invoiceData.SyncToken = latestSyncToken;
    invoiceData.retryCount++; // Increment retry count
    Logger.log(`üîÑ Retrying update (Attempt ${invoiceData.retryCount}) with new SyncToken: ${latestSyncToken}`);

    return updateInvoiceInQBO(invoiceData); // Retry with new token
} else if (invoiceData.retryCount >= 3) {
    Logger.log("‚ùå Max retries reached for Stale Object Error. Update aborted.");
    return; // üî¥ Prevents further execution after max retries
}

// üöÄ **Remove retryCount before sending to QuickBooks**
delete invoiceData.retryCount;

// ‚úÖ Proceed with the final API request
const response = fetchWithRetry(apiUrl, options);
Logger.log("‚úÖ QuickBooks API Response: " + response.getContentText());

if (response && response.getResponseCode() !== 200) { 
    let responseJson = JSON.parse(response.getContentText());
    if (responseJson.Fault) {
        Logger.log("‚ùå API Error: " + JSON.stringify(responseJson.Fault));
    }
}


    }
  } catch (error) {
    Logger.log("‚ùå Error in updateInvoiceInQBO: " + error.message);
  }
}

/**
 * üöÄ Pushes the invoice data from Google Sheets to QuickBooks.
 * @param {GoogleAppsScript.Spreadsheet.Sheet} sheet - The sheet containing invoice data.
 */
function pushInvoiceToQBO(sheet) {
  checkRateLimit();  // üõ° Prevent hitting API rate limits

  try {
    Logger.log("üìå Starting invoice sync for sheet: " + sheet.getName());

    // ‚úÖ Extract invoice details from the sheet
    var invoiceNumber = sheet.getRange("A1").getValue().replace("Invoice Number: ", "").trim();
    var txnDate = sheet.getRange("A2").getValue().replace("Date: ", "").trim();
    var customer = sheet.getRange("A3").getValue().replace("Customer: ", "").trim();
    var total = parseFloat(sheet.getRange("A4").getValue().replace("Total: $", "").trim());

    Logger.log("üìÜ Transaction Date: " + txnDate);
    Logger.log("üë§ Customer Name: " + customer);
    Logger.log("üí∞ Invoice Total: " + total);

    // ‚úÖ Check if the invoice already exists in QuickBooks
    var invoiceId = getInvoiceIdByDocNumber(invoiceNumber);
    if (!invoiceId) {
      Logger.log("‚ùå Invoice not found. Creating a new invoice.");
      createInvoiceInQBO(sheet);
      return;
    }

    // ‚úÖ Fetch SyncToken for the existing invoice
    var syncTokens = getAllSyncTokens([invoiceId]);
    var syncToken = syncTokens[invoiceId] || "0";  // Use default "0" if missing

    // ‚úÖ Prepare the invoice data for update
    var invoiceData = {
      "Id": invoiceId,
      "SyncToken": syncToken,
      "DocNumber": invoiceNumber,
      "TxnDate": txnDate,
      "CustomerRef": { "name": customer },
      "TotalAmt": 0,  // Will be calculated dynamically
      "Line": []
    };

    Logger.log("üîÑ Collecting line items for invoice...");

    // ‚úÖ Read line items from the sheet
    var lastRow = sheet.getLastRow();
    var calculatedTotal = 0;

    for (var row = 7; row <= lastRow; row++) {
      var itemName = sheet.getRange("A" + row).getValue().trim();
      var qty = parseFloat(sheet.getRange("B" + row).getValue());
      var rate = parseFloat(sheet.getRange("C" + row).getValue());
      var amount = parseFloat(sheet.getRange("D" + row).getValue());
      var itemRef = sheet.getRange("E" + row).getValue();

      // ‚úÖ Add line item if all fields are valid
      if (itemName && qty && rate && amount && itemRef) {
        Logger.log(`üõí Item: ${itemName} | Qty: ${qty} | Rate: ${rate} | Amount: ${amount} | ItemRef: ${itemRef}`);

        invoiceData.Line.push({
          "DetailType": "SalesItemLineDetail",
          "Amount": amount,
          "Description": itemName,  // Initially set to the sheet-provided name
          "SalesItemLineDetail": {
            "ItemRef": { "value": String(itemRef) },
            "Qty": qty,
            "UnitPrice": rate,
            "TaxCodeRef": { "value": "NON" }
          }
        });

        calculatedTotal += amount;
      }
    }

    // ‚úÖ Update the invoice total based on actual calculations
    invoiceData.TotalAmt = calculatedTotal;

    // ‚úÖ Overwrite item names with correct names from QuickBooks (if mismatched)
    invoiceData.Line.forEach((line) => {
      if (line.SalesItemLineDetail) {
        var itemId = line.SalesItemLineDetail.ItemRef.value;
        var correctName = getItemNameById(itemId); // Fetch correct name from QuickBooks

        if (correctName && line.Description !== correctName) {
          Logger.log(`üîÑ Overwriting Description: ${line.Description} ‚Üí ${correctName}`);
          line.Description = correctName;  // Fix mismatched item names
        }
      }
    });

    Logger.log("üí∞ Final Calculated Total: " + invoiceData.TotalAmt);
    Logger.log("üì§ Sending Invoice Update (UPDATE): " + JSON.stringify(invoiceData));

    // ‚úÖ Push the updated invoice to QuickBooks
    updateInvoiceInQBO(invoiceData);

  } catch (error) {
    Logger.log("‚ùå Error in pushInvoiceToQBO: " + error.message);
  }
}




function fetchWithRetry(url, options, maxRetries = 3) {
  let attempts = 0;
  let delay = 2000; // Start with 2 seconds

  while (attempts < maxRetries) {
    try {
      const response = UrlFetchApp.fetch(url, options);
      const statusCode = response.getResponseCode();

      if (statusCode === 200) {
        return response;  // ‚úÖ Success, return response
      } else if (statusCode === 429 || (statusCode >= 500 && statusCode < 600)) {
        // Handle 429 (Rate Limit) and 500-599 (Server Errors)
        Logger.log(`‚ö†Ô∏è API Limit or Server Error (${statusCode}). Retrying in ${delay / 1000} seconds...`);
        Utilities.sleep(delay);
        delay *= 2; // Exponential backoff
      } else {
        Logger.log(`‚ùå API request failed with status: ${statusCode}`);
        return response;  // Return response for further analysis
      }
    } catch (error) {
      Logger.log(`‚ùå Network Error: ${error.message}`);
      attempts++;
      if (attempts >= maxRetries) {
        Logger.log("‚ùå Max retries reached. Returning null.");
        return null;  // All retries failed
      }
      Logger.log(`üîÑ Retrying after ${delay / 1000} seconds (Attempt ${attempts}/${maxRetries})...`);
      Utilities.sleep(delay);
      delay *= 2;
    }
  }

  Logger.log("‚ùå Max retry limit reached for API request.");
  return null;
}



function onEditTrigger(e) {
    var uniqueRunId = new Date().getTime(); // Unique timestamp for each execution
    Logger.log(`üîÑ New Execution ID: ${uniqueRunId}`);

    var lock = LockService.getScriptLock();
    if (!lock.tryLock(500)) {
        Logger.log(`‚õî Execution ID ${uniqueRunId} skipped due to active lock.`);
        return; // üî• If another instance is running, exit immediately
    }

    try {
        var sheet = e.source.getActiveSheet();
        var range = e.range;
        Logger.log(`üîÑ Execution ID ${uniqueRunId}: Triggered onEditTrigger for range: ${range.getA1Notation()} in sheet: ${sheet.getName()}`);

        // ‚úÖ Handle "Menu" sheet checkboxes
        if (sheet.getName() === "Menu" && (range.getA1Notation() === "A2" || range.getA1Notation() === "A3")) {
            var check1 = sheet.getRange("A2").getValue();
            var check2 = sheet.getRange("A3").getValue();
            if (check1 && check2) {
                Logger.log(`‚úÖ Execution ID ${uniqueRunId}: Both checkboxes checked in 'Menu'! Refreshing Invoices...`);
                refreshInvoices(); 
                sheet.getRange("A2").setValue(false);
                sheet.getRange("A3").setValue(false);
            }
        }

        // ‚úÖ Handle invoice sync checkboxes in invoice sheets
        if (range.getA1Notation() === "D2" || range.getA1Notation() === "D3") {
            var checkD2 = sheet.getRange("D2").getValue();
            var checkD3 = sheet.getRange("D3").getValue();
            if (checkD2 && checkD3) {
                var invoiceNumber = sheet.getRange("A1").getValue().replace("Invoice Number: ", "").trim();
                if (invoiceNumber) {
                    Logger.log(`‚úÖ Execution ID ${uniqueRunId}: Both checkboxes checked! Syncing Invoice: ${invoiceNumber}`);
                    pushInvoiceToQBO(sheet);
                    sheet.getRange("D2").setValue(false);
                    sheet.getRange("D3").setValue(false);
                } else {
                    Logger.log(`‚ùå Execution ID ${uniqueRunId}: No invoice number found in A1.`);
                }
            }
        }
    } catch (error) {
        Logger.log(`‚ùå Execution ID ${uniqueRunId}: Error in onEditTrigger: ${error.message}`);
    } finally {
        lock.releaseLock(); // üîì Ensure lock is always released
        Logger.log(`üîì Execution ID ${uniqueRunId} released lock.`);
    }
}


function createInstallableTrigger() {
  var triggers = ScriptApp.getProjectTriggers();
  
  // Avoid duplicate triggers
  for (var i = 0; i < triggers.length; i++) {
    if (triggers[i].getHandlerFunction() === "onEditTrigger") {
      Logger.log("üöÄ Installable trigger already exists!");
      return;
    }
  }
  
  ScriptApp.newTrigger("onEditTrigger")
    .forSpreadsheet(SpreadsheetApp.openById('17V9u1Bz0LM0xOPz3AayXcRh4xIvYnRamfb2x3f9O7Z8'))
    .onEdit()
    .create();
  
  Logger.log("‚úÖ Installable trigger created!");
}


/**
 * ‚úÖ Run this function once to set up the trigger!
 */
function setup() {
  createInstallableTrigger();
}



function encryptData(plainText) {
    return encryptWithKMS(plainText);
}

function decryptData(cipherText) {
    return decryptWithKMS(cipherText);
}


function testEncryption() {
    var passphrase = '0nofFCM8RE4KrUKSHG-oTiOcoOItxm1Fao1GWhLV-2s';
    var originalText = 'Sensitive data to encrypt';

    // Encrypt the data
    var encryptedText = encryptData(originalText, passphrase);
    Logger.log('Encrypted Text: ' + encryptedText);

    // Decrypt the data
    var decryptedText = decryptData(encryptedText, passphrase);
    Logger.log('Decrypted Text: ' + decryptedText);
}


function storeClientCredentialsSecurely() {
  const clientId = "YOUR_CLIENT_ID";
  const clientSecret = "YOUR_CLIENT_SECRET";
  
  PropertiesService.getScriptProperties().setProperty("ENCRYPTED_CLIENT_ID", encryptWithKMS(clientId));
  PropertiesService.getScriptProperties().setProperty("ENCRYPTED_CLIENT_SECRET", encryptWithKMS(clientSecret));
  
  Logger.log("üîí Client credentials securely stored using KMS.");
}




function authorize() {
  var service = getOAuthService();
  if (!service.hasAccess()) {
    var authorizationUrl = service.getAuthorizationUrl();
    Logger.log('üìå Open the following URL to authorize the app: ' + authorizationUrl);
  } else {
    Logger.log('‚úÖ App already authorized.');
  }
}


function clearOAuthTokens() {
  var service = getOAuthService();
  service.reset();
  Logger.log("üîÑ Cleared stored OAuth tokens.");
}



function verifyAuthorization() {
  var service = getOAuthService();
  if (service.hasAccess()) {
    Logger.log("‚úÖ Successfully authorized and access token stored for all users.");
  } else {
    Logger.log("‚ùå Authorization failed. Please run 'authorize()' as the admin.");
  }
}



function createTriggers() {
  const ss = SpreadsheetApp.openById('17V9u1Bz0LM0xOPz3AayXcRh4xIvYnRamfb2x3f9O7Z8');
  
  ScriptApp.newTrigger('onEditTrigger')
    .forSpreadsheet(ss)
    .onEdit()
    .create();
}




function sendInvoiceToGoogleChat(invoiceData) {
  const webhookUrl = 'https://chat.googleapis.com/v1/spaces/AAAA2YN5jvM/messages?key=AIzaSyDdI0hCZtE6vySjMm-WEfRq3CPzqKqqsHI&token=UDEkfXiBBXNUpG1RpPwaKIzGcpp2OS-eDjjvDn4vYD4';
  const message = {
    text: `üßæ *Invoice Update*\n\nInvoice Number: ${invoiceData.DocNumber}\nCustomer: ${invoiceData.CustomerRef.name}\nTotal: $${invoiceData.TotalAmt}`
  };

  const options = {
    method: 'post',
    contentType: 'application/json',
    payload: JSON.stringify(message)
  };

  UrlFetchApp.fetch(webhookUrl, options);
}


