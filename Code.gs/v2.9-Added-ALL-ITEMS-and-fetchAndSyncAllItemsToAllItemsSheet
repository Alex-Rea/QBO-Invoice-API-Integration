var requestCount = 0;
var scriptProperties = PropertiesService.getScriptProperties();

// üåê Cloud KMS Config
const PROJECT_ID = "qbo-api-invoice-integration";
const LOCATION_ID = "global"; // Change if using a specific region
const KEY_RING_ID = "my-key-ring";
const KEY_ID = "my-encryption-key";
const BASE_URL = "https://quickbooks.api.intuit.com/v3/company/";
const COMPANY_ID = PropertiesService.getScriptProperties().getProperty("COMPANY_ID");


// üõ† Cached Auth Tokens
var lastKmsToken = null;
var lastKmsTokenTime = null;
var lastAccessToken = null;
var lastTokenTime = null;

// üîê Fetch Secret from Google Secret Manager
function getSecretFromSecretManager(secretName) {
  const url = `https://secretmanager.googleapis.com/v1/projects/${PROJECT_ID}/secrets/${secretName}/versions/latest:access`;

  const options = {
    method: "get",
    headers: {
      Authorization: `Bearer ${ScriptApp.getOAuthToken()}`,
      Accept: "application/json"
    },
    muteHttpExceptions: true
  };

  const response = UrlFetchApp.fetch(url, options);
  const json = JSON.parse(response.getContentText());

  if (response.getResponseCode() === 200 && json.payload && json.payload.data) {
    return Utilities.newBlob(Utilities.base64Decode(json.payload.data)).getDataAsString();
  } else {
    Logger.log(`‚ùå Error retrieving secret '${secretName}': ${response.getContentText()}`);
    return null;
  }
}

// üîë Get OAuth Token for Cloud KMS
function getAuthToken() {
  const now = new Date().getTime();
  if (lastKmsToken && now - lastKmsTokenTime < 3600000) {
    Logger.log("‚úÖ Using cached Cloud KMS Auth Token.");
    return lastKmsToken;
  }

  const secretJson = getSecretFromSecretManager("SERVICE_ACCOUNT_JSON");
  if (!secretJson) {
    Logger.log("‚ùå Failed to retrieve service account JSON from Secret Manager.");
    return null;
  }

  const credentials = JSON.parse(secretJson);
  const tokenResponse = UrlFetchApp.fetch("https://oauth2.googleapis.com/token", {
    method: "post",
    contentType: "application/json",
    payload: JSON.stringify({
      grant_type: "urn:ietf:params:oauth:grant-type:jwt-bearer",
      assertion: createJwt(credentials)
    })
  });

  const response = JSON.parse(tokenResponse.getContentText());
  if (response.access_token) {
    lastKmsToken = response.access_token;
    lastKmsTokenTime = now;
    return lastKmsToken;
  }

  Logger.log("‚ùå Failed to get Cloud KMS Auth Token.");
  return null;
}

// üîê Create JWT for Cloud KMS Authentication
function createJwt(credentials) {
    var now = Math.floor(Date.now() / 1000);
    var payload = {
        iss: credentials.client_email,
        scope: "https://www.googleapis.com/auth/cloudkms",
        aud: "https://oauth2.googleapis.com/token",
        exp: now + 3600,
        iat: now
    };

    var encodedHeader = Utilities.base64EncodeWebSafe(JSON.stringify({ alg: "RS256", typ: "JWT" }));
    var encodedPayload = Utilities.base64EncodeWebSafe(JSON.stringify(payload));
    var signatureInput = encodedHeader + "." + encodedPayload;
    var signature = Utilities.computeRsaSha256Signature(signatureInput, credentials.private_key);
    return signatureInput + "." + Utilities.base64EncodeWebSafe(signature);
}


// üîí Encrypt Data with Cloud KMS (Optimized)
function encryptWithKMS(plainText) {
    if (!lastKmsToken) lastKmsToken = getAuthToken(); // Only fetch if missing

    var url = `https://cloudkms.googleapis.com/v1/projects/${PROJECT_ID}/locations/${LOCATION_ID}/keyRings/${KEY_RING_ID}/cryptoKeys/${KEY_ID}:encrypt`;
    var requestBody = { plaintext: Utilities.base64Encode(plainText) };

    var response = UrlFetchApp.fetch(url, {
        method: "post",
        headers: { Authorization: `Bearer ${lastKmsToken}`, "Content-Type": "application/json" },
        payload: JSON.stringify(requestBody)
    });

    return JSON.parse(response.getContentText()).ciphertext;
}

// üîì Decrypt Data with Cloud KMS (Optimized)
function decryptWithKMS(encryptedText) {
    if (!lastKmsToken) lastKmsToken = getAuthToken(); // Only fetch if missing

    var url = `https://cloudkms.googleapis.com/v1/projects/${PROJECT_ID}/locations/${LOCATION_ID}/keyRings/${KEY_RING_ID}/cryptoKeys/${KEY_ID}:decrypt`;
    var requestBody = { ciphertext: encryptedText };

    var response = UrlFetchApp.fetch(url, {
        method: "post",
        headers: { Authorization: `Bearer ${lastKmsToken}`, "Content-Type": "application/json" },
        payload: JSON.stringify(requestBody)
    });

    return Utilities.newBlob(
        Utilities.base64Decode(JSON.parse(response.getContentText()).plaintext)
    ).getDataAsString();
}


// üîë Retrieve and Decrypt QuickBooks Credentials
function getDecryptedClientCredentials() {
    var encryptedClientId = PropertiesService.getScriptProperties().getProperty("ENCRYPTED_CLIENT_ID");
    var encryptedClientSecret = PropertiesService.getScriptProperties().getProperty("ENCRYPTED_CLIENT_SECRET");

    if (!encryptedClientId || !encryptedClientSecret) {
        Logger.log("‚ùå No stored credentials found.");
        return null;
    }

    return {
        CLIENT_ID: decryptWithKMS(encryptedClientId),
        CLIENT_SECRET: decryptWithKMS(encryptedClientSecret)
    };
}


// üîë Get QuickBooks Access Token with Expiration & Refresh Token Handling
function getAccessToken() {
  checkRateLimit();  // üõ° Prevent hitting rate limits

  const now = new Date().getTime();
  if (lastAccessToken && now - lastTokenTime < 3600000) {
    Logger.log("‚úÖ Using Cached Access Token.");
    return lastAccessToken;
  }

  const service = getOAuthService();
  if (!service.hasAccess()) {
    Logger.log("‚ùå Access token expired or invalid. Attempting to refresh token...");

    // üîÑ Automatically refresh the token if it‚Äôs expired
    if (!service.refresh()) {
      Logger.log("‚ùå Refresh token expired or invalid. User re-authorization required.");
      promptReauthorization();
      return null;
    }
  }

  const accessToken = service.getAccessToken();
  lastAccessToken = accessToken;
  lastTokenTime = now;

  Logger.log("üîë Access Token Retrieved: " + maskToken(accessToken));
  return accessToken;
}

// üîÑ Trigger reauthorization prompt if refresh token fails
function promptReauthorization() {
  Logger.log("üîÑ Access token expired. Re-authorization required.");
  const service = getOAuthService();
  const authorizationUrl = service.getAuthorizationUrl();
  Logger.log('üìå Please reauthorize the app: ' + authorizationUrl);
}

// üîí Mask sensitive information in logs
function maskToken(token) {
  return token ? token.substring(0, 4) + "****" + token.slice(-4) : null;
}

// üîê Set up OAuth 2.0 Service
function getOAuthService() {
  const credentials = getDecryptedClientCredentials();  // Securely decrypt stored credentials

  return OAuth2.createService('QuickBooks')
    .setAuthorizationBaseUrl('https://appcenter.intuit.com/connect/oauth2')
    .setTokenUrl('https://oauth.platform.intuit.com/oauth2/v1/tokens/bearer')
    .setClientId(credentials.CLIENT_ID)
    .setClientSecret(credentials.CLIENT_SECRET)
    .setCallbackFunction('authCallback')
    .setPropertyStore(PropertiesService.getScriptProperties())
    .setScope('com.intuit.quickbooks.accounting')
    .setTokenHeaders({
      'Accept': 'application/json'
    })
    .setParam('response_type', 'code')
    .setParam('redirect_uri', `https://script.google.com/macros/d/${ScriptApp.getScriptId()}/usercallback`);
}

// üîÑ Handle OAuth callback from Intuit
function authCallback(request) {
  const service = getOAuthService();
  const authorized = service.handleCallback(request);

  if (authorized) {
    Logger.log("‚úÖ Successfully authorized.");
    return HtmlService.createHtmlOutput('Authorization successful! You can close this tab.');
  } else {
    // üîç Check if it's due to an invalid grant or expired token
    const error = request.parameter.error;
    
    if (error === 'invalid_grant') {
      Logger.log("‚ùå Invalid grant error detected. Token may have expired or been revoked.");
      return HtmlService.createHtmlOutput('Authorization failed due to invalid grant. Please reauthorize.');
    }

    if (error === 'csrf') {
      Logger.log("‚ùå CSRF error detected. Possible unauthorized request attempt.");
      return HtmlService.createHtmlOutput('Security error detected (CSRF). Please try again or contact support.');
    }

    Logger.log("‚ùå Authorization denied or unknown error: " + JSON.stringify(request.parameter));
    return HtmlService.createHtmlOutput('Authorization denied or an unknown error occurred.');
  }
}


function isXmlResponse(responseText) {
  return responseText.trim().startsWith("<?xml");
}


// üîë Retrieve & Decrypt QuickBooks Credentials
function getDecryptedClientCredentials() {
    var encryptedClientId = PropertiesService.getScriptProperties().getProperty("ENCRYPTED_CLIENT_ID");
    var encryptedClientSecret = PropertiesService.getScriptProperties().getProperty("ENCRYPTED_CLIENT_SECRET");

    if (!encryptedClientId || !encryptedClientSecret) return Logger.log("‚ùå No stored credentials found.");

    return {
        CLIENT_ID: decryptWithKMS(encryptedClientId),
        CLIENT_SECRET: decryptWithKMS(encryptedClientSecret)
    };
}

function checkRateLimit() {
  requestCount++;
  if (requestCount % 5 === 0) {  // Every 5 requests, wait 1.5 seconds
    Logger.log("‚è≥ Adding delay to prevent hitting QuickBooks rate limits...");
    Utilities.sleep(1500);
  }
}

let itemCache = {};  // ‚úÖ Cache for item data (id ‚Üí name)

function fetchAllItems() {
  checkRateLimit();

  const accessToken = getAccessToken();
  if (!accessToken) {
    Logger.log("‚ùå No access token for fetching items.");
    return {};
  }

  let allItems = {};
  let startPosition = 1;
  let hasMore = true;

  while (hasMore) {
    const query = `SELECT Id, Name FROM Item STARTPOSITION ${startPosition} MAXRESULTS 1000`;
    const apiUrl = BASE_URL + COMPANY_ID + "/query?query=" + encodeURIComponent(query);

    const options = {
      method: "get",
      headers: {
        "Authorization": `Bearer ${accessToken}`,
        "Accept": "application/json"
      },
      muteHttpExceptions: true
    };

    const response = UrlFetchApp.fetch(apiUrl, options);
    const json = JSON.parse(response.getContentText());

    if (json.QueryResponse && json.QueryResponse.Item) {
      json.QueryResponse.Item.forEach(item => {
        allItems[item.Id] = item.Name;
      });

      if (json.QueryResponse.startPosition + json.QueryResponse.maxResults > json.QueryResponse.totalCount) {
        hasMore = false;
      } else {
        startPosition += 1000;
      }
    } else {
      hasMore = false;
    }
  }

  Logger.log(`‚úÖ Fetched all items: ${Object.keys(allItems).length} items.`);
  itemCache = allItems; // Cache all fetched items
  return allItems;
}




function refreshInvoices() {
  checkRateLimit();

  // ‚úÖ Fetch all items once and cache
  fetchAllItems();

  const ss = SpreadsheetApp.openById('17V9u1Bz0LM0xOPz3AayXcRh4xIvYnRamfb2x3f9O7Z8');
  const menuSheet = ss.getSheetByName("Menu");

  if (!menuSheet) {
    Logger.log("‚ùå Error: 'Menu' sheet not found.");
    return;
  }

  // ‚úÖ Step 1: Check if A2 and A3 are both checked
  const checkA2 = menuSheet.getRange("A2").getValue();
  const checkA3 = menuSheet.getRange("A3").getValue();

  if (!(checkA2 && checkA3)) {
    Logger.log("‚ùå A2 and A3 must be checked to refresh invoices.");
    return;
  }

  Logger.log("‚úÖ Both checkboxes checked in 'Menu'! Refreshing Invoices...");

  // ‚úÖ Step 2: Fetch only the 10 most recent invoices from QuickBooks
  const accessToken = getAccessToken();
  if (!accessToken) {
    Logger.log("‚ùå No access token retrieved!");
    return;
  }

  const query = `SELECT * FROM Invoice ORDERBY TxnDate DESC STARTPOSITION 1 MAXRESULTS 10`;
  const apiUrl = BASE_URL + COMPANY_ID + "/query?query=" + encodeURIComponent(query);

  const options = {
    method: "get",
    headers: {
      "Authorization": `Bearer ${accessToken}`,
      "Accept": "application/json"
    },
    muteHttpExceptions: true
  };

  const response = UrlFetchApp.fetch(apiUrl, options);
  const json = JSON.parse(response.getContentText());

  if (!json.QueryResponse || !json.QueryResponse.Invoice) {
    Logger.log("‚ö†Ô∏è No invoices found in QuickBooks!");
    return;
  }

  const invoices = json.QueryResponse.Invoice;
  Logger.log(`‚úÖ Retrieved the 10 most recent invoices.`);

  // ‚úÖ Step 3: Identify and delete old invoice sheets using Set for faster lookup
  const sheets = ss.getSheets();
  const existingSheetNames = sheets.map(sheet => sheet.getName());
  const recentInvoiceNumbers = invoices.map(invoice => invoice.DocNumber);
  const recentInvoiceSheets = new Set(recentInvoiceNumbers.map(num => `Inv_${num}`));

  sheets.forEach(sheet => {
    const sheetName = sheet.getName();
    if (sheetName.startsWith("Inv_") && !recentInvoiceSheets.has(sheetName)) {
      try {
        ss.deleteSheet(sheet);
        Logger.log(`üóë Deleted outdated invoice sheet: ${sheetName}`);
      } catch (e) {
        Logger.log(`‚ö†Ô∏è Could not delete sheet: ${sheetName} | Error: ${e.message}`);
      }
    }
  });

  // ‚úÖ Step 4: Recreate the menu links with exactly 10 invoices
  let invoiceLinks = [];
  let invoiceDescriptions = [];

  invoices.forEach(invoice => {
    const invoiceNumber = invoice.DocNumber || `Invoice_${invoice.Id}`;
    const invoiceTabName = `Inv_${invoiceNumber}`;
    const customerName = invoice.CustomerRef?.name || "Unknown Customer";

    // ‚úÖ Ensure the invoice sheet exists
    let sheet = ss.getSheetByName(invoiceTabName);
    if (!sheet) {
      sheet = ss.insertSheet(invoiceTabName);
      formatInvoiceSheet(sheet, invoice);
    }

    // ‚úÖ Use `gid` for hyperlinks
    let sheetGid = sheet.getSheetId();
    let linkFormula = `=HYPERLINK("https://docs.google.com/spreadsheets/d/${ss.getId()}/edit#gid=${sheetGid}", "${invoiceNumber}")`;

    invoiceLinks.push([linkFormula]);         // Column A (Invoice Links)
    invoiceDescriptions.push([customerName]); // Column B (Customer Name)
  });

  // ‚úÖ Overwrite the menu sheet with exactly 10 invoices
  const totalLinks = invoiceLinks.length;
  if (totalLinks > 0) {
    const linkRange = menuSheet.getRange(5, 1, totalLinks, 1);
    const descRange = menuSheet.getRange(5, 2, totalLinks, 1);

    linkRange.setFormulas(invoiceLinks);
    descRange.setValues(invoiceDescriptions);

    // ‚úÖ Clear extra cells beyond the most recent 10
    if (totalLinks < 96) {
      const extraClearRange = menuSheet.getRange(5 + totalLinks, 1, 96 - totalLinks, 2);
      extraClearRange.clearContent();
    }
  } else {
    Logger.log("‚ö†Ô∏è No new invoices to display in the menu.");
  }

  // ‚úÖ Step 5: Reset A2 & A3 checkboxes
  menuSheet.getRange("A2").setValue(false);
  menuSheet.getRange("A3").setValue(false);

  Logger.log("‚úÖ Invoice refresh complete! Menu sheet updated with the 10 most recent invoices.");
}



function deleteAllInvoices() {
  const ss = SpreadsheetApp.openById('17V9u1Bz0LM0xOPz3AayXcRh4xIvYnRamfb2x3f9O7Z8');
  const menuSheet = ss.getSheetByName("Menu");

  if (!menuSheet) {
    Logger.log("‚ùå Error: 'Menu' sheet not found.");
    return;
  }

  // ‚úÖ Step 1: Check if B2 and B3 checkboxes are both checked
  const checkB2 = menuSheet.getRange("B2").getValue();
  const checkB3 = menuSheet.getRange("B3").getValue();

  if (!(checkB2 && checkB3)) {
    Logger.log("‚ùå B2 and B3 must be checked to delete all invoices.");
    return;
  }

  Logger.log("üóë Both checkboxes checked in 'Menu'! Deleting all invoice sheets...");

  // ‚úÖ Step 2: Delete all sheets starting with "Inv_"
  const sheets = ss.getSheets();
  sheets.forEach(sheet => {
    const sheetName = sheet.getName();
    if (sheetName.startsWith("Inv_")) {
      try {
        ss.deleteSheet(sheet);
        Logger.log(`üóë Deleted invoice sheet: ${sheetName}`);
      } catch (e) {
        Logger.log(`‚ö†Ô∏è Could not delete sheet: ${sheetName} | Error: ${e.message}`);
      }
    }
  });

  // ‚úÖ Step 3: Clear the menu sheet links
  const clearMenuRange = menuSheet.getRange("A5:B100");
  clearMenuRange.clearContent();
  Logger.log("üßπ Cleared all invoice links from the menu sheet.");

  // ‚úÖ Step 4: Reset B2 and B3 checkboxes
  menuSheet.getRange("B2").setValue(false);
  menuSheet.getRange("B3").setValue(false);

  Logger.log("‚úÖ All invoices deleted and menu cleared.");
}




function formatInvoiceSheet(newSheet, invoice) {
  const managementEmails = [
    "alex.rea@casinosnaks.com",
    "ceci.pagnozzi@casinosnaks.com",
    "jim.rea@casinosnaks.com",
    "penny.rea@casinosnaks.com",
    "jprea8@gmail.com"
  ]; // Management emails

  // Set Invoice Metadata
  newSheet.getRange("A1").setValue("Invoice Number: " + (invoice.DocNumber || "N/A"));
  newSheet.getRange("A2").setValue("Date: " + (invoice.TxnDate || "N/A"));
  newSheet.getRange("A3").setValue("Customer: " + (invoice.CustomerRef ? invoice.CustomerRef.name : "Unknown"));

  // Auto-updating total
  newSheet.getRange("A4").setFormula('="Total: $" & SUM(D7:D)');

  // Set headers
  newSheet.getRange("A6").setValue("Item");
  newSheet.getRange("B6").setValue("Quantity");
  newSheet.getRange("C6").setValue("Rate");
  newSheet.getRange("D6").setValue("Amount");
  newSheet.getRange("E6").setValue("ItemRef");

  let row = 7;

  if (invoice.Line && invoice.Line.length > 0) {
    invoice.Line.forEach(function (line) {
      if (line.SalesItemLineDetail) {
        const itemRef = line.SalesItemLineDetail.ItemRef ? line.SalesItemLineDetail.ItemRef.value : "N/A";
        const itemName = (itemRef && itemRef !== "N/A") ? getItemNameById(itemRef) : "Unknown";

        // Set item details
        newSheet.getRange("A" + row).setValue(itemName);
        newSheet.getRange("B" + row).setValue(line.SalesItemLineDetail.Qty || 0);
        newSheet.getRange("C" + row).setValue(line.SalesItemLineDetail.UnitPrice || 0);
        newSheet.getRange("D" + row).setFormula("=B" + row + "*C" + row);
        newSheet.getRange("E" + row).setValue(itemRef);

        row++;
      }
    });
  } else {
    newSheet.getRange("A7").setValue("‚ö†Ô∏è No items found for this invoice.");
  }

  // Add checkboxes for pushing changes
  newSheet.getRange("D1").setValue("Push Changes to QBO");
  newSheet.getRange("D2").insertCheckboxes();
  newSheet.getRange("D3").insertCheckboxes();

  // Add checkboxes for sending PDF to Gchat
  newSheet.getRange("E1").setValue("Send PDF to Gchat");
  newSheet.getRange("E2").insertCheckboxes().setValue(false);
  newSheet.getRange("E3").insertCheckboxes().setValue(false);

  // Add "Apply Special Pricing" checkbox setup
  newSheet.getRange("C1").setValue("Apply Special Pricing");
  newSheet.getRange("C2").insertCheckboxes().setValue(false);
  newSheet.getRange("C3").insertCheckboxes().setValue(false);

  // Add dropdown for selecting user
  newSheet.getRange("F1").setValue("Select Name");
  const dropdownValues = ["Alex", "Angel", "Ceci", "Ismael", "Jim", "Penny", "Richard", "TABLET 1"];
  const rule = SpreadsheetApp.newDataValidation()
    .requireValueInList(dropdownValues)
    .setAllowInvalid(false)
    .build();
  newSheet.getRange("F2").setDataValidation(rule);

  // üîí Lock the entire sheet first
  const protection = newSheet.protect().setDescription("Invoice Sheet Protection");
  protection.addEditors(managementEmails); // Only management can edit locked cells
  protection.removeEditors(protection.getEditors().filter(editor => !managementEmails.includes(editor.getEmail()))); // Remove non-management editors

  // ‚úÖ Define unprotected ranges (only editable by non-management)
  let unprotectedRanges = [
    newSheet.getRange(7, 2, row - 7, 1), // Quantities (Column B)
    newSheet.getRange("E2:E3"),           // Checkboxes for sending PDF to Gchat
    newSheet.getRange("F2"),              // Name selection dropdown
    newSheet.getRange("C2:C3")            // Checkboxes for "Apply Special Pricing"
  ];

  protection.setUnprotectedRanges(unprotectedRanges);

  Logger.log("‚úÖ Entire sheet locked, only quantities, checkboxes, and dropdowns are editable by non-management.");
}

function getAllSyncTokens(invoiceIds) {
  if (!invoiceIds.length) {
    return {};
  }

  checkRateLimit();

  const accessToken = getAccessToken();
  if (!accessToken) {
    Logger.log("‚ùå No access token, cannot fetch SyncTokens.");
    return {};
  }
  Logger.log("üîë Using Access Token: " + maskToken(accessToken));

  const query = "SELECT Id, SyncToken FROM Invoice WHERE Id IN (" + invoiceIds.map(id => `'${id}'`).join(",") + ")";
  const apiUrl = BASE_URL + COMPANY_ID + "/query?query=" + encodeURIComponent(query);

  const headers = {
    "Authorization": "Bearer " + accessToken,
    "Accept": "application/json"
  };

  const options = {
    method: "get",
    headers: headers,
    muteHttpExceptions: true
  };

  const response = fetchWithRetry(apiUrl, options);
  const json = JSON.parse(response.getContentText());

  let syncTokenMap = {};
  if (json.QueryResponse && json.QueryResponse.Invoice) {
    json.QueryResponse.Invoice.forEach(invoice => {
      syncTokenMap[invoice.Id] = invoice.SyncToken;
    });
    Logger.log("‚úÖ Retrieved SyncTokens for " + json.QueryResponse.Invoice.length + " invoices.");
  } else {
    Logger.log("‚ùå Failed to retrieve SyncTokens.");
  }

  return syncTokenMap;
}

function getInvoiceByDocNumber(docNumber) {
  checkRateLimit();

  try {
    const accessToken = getAccessToken();
    if (!accessToken) {
      Logger.log("‚ùå No access token, cannot retrieve invoice.");
      return null;
    }

    const query = "SELECT Id, SyncToken, CustomerRef FROM Invoice WHERE DocNumber = '" + docNumber + "'";
    const apiUrl = BASE_URL + COMPANY_ID + "/query?query=" + encodeURIComponent(query);

    const headers = {
      "Authorization": "Bearer " + accessToken,
      "Accept": "application/json"
    };

    const options = {
      method: "get",
      headers: headers,
      muteHttpExceptions: true
    };

    const response = fetchWithRetry(apiUrl, options);
    const json = JSON.parse(response.getContentText());

    if (json.QueryResponse && json.QueryResponse.Invoice && json.QueryResponse.Invoice.length > 0) {
      const invoice = json.QueryResponse.Invoice[0];

      Logger.log("‚úÖ Invoice found: " + JSON.stringify(invoice)); // üîÑ Keep logging for debugging

      if (!invoice.Id || !invoice.SyncToken) {
        Logger.log("‚ö†Ô∏è Invoice data is missing critical fields (Id/SyncToken).");
        return null;
      }

      return invoice;
    } else {
      Logger.log("‚ùå Invoice not found for DocNumber: " + docNumber);
      return null;
    }

  } catch (error) {  // ‚úÖ Missing catch block added here!
    Logger.log("‚ùå Error in getInvoiceByDocNumber: " + error.message);
    return null;
  }
}


function getInvoiceIdByDocNumber(docNumber) {
  checkRateLimit();

  const accessToken = getAccessToken();
  if (!accessToken) {
    Logger.log("‚ùå No access token, cannot fetch invoice ID.");
    return null;
  }

  const query = "SELECT Id FROM Invoice WHERE DocNumber = '" + docNumber + "'";
  const apiUrl = BASE_URL + COMPANY_ID + "/query?query=" + encodeURIComponent(query);

  const headers = {
    "Authorization": "Bearer " + accessToken,
    "Accept": "application/json"
  };

  const options = {
    method: "get",
    headers: headers,
    muteHttpExceptions: true
  };

  const response = fetchWithRetry(apiUrl, options);
  const json = JSON.parse(response.getContentText());

  if (json.QueryResponse && json.QueryResponse.Invoice && json.QueryResponse.Invoice.length > 0) {
    Logger.log("‚úÖ Invoice found: " + JSON.stringify(json.QueryResponse.Invoice[0]));
    return json.QueryResponse.Invoice[0].Id;
  } else {
    Logger.log("‚ùå No existing invoice found for DocNumber: " + docNumber);
    return null;
  }
}


function getItemDetailsById(itemId) {
  // ‚úÖ Use cached item if available
  if (itemCache[itemId]) {
    Logger.log(`‚úÖ Cached Item Found: ${JSON.stringify(itemCache[itemId])}`);
    return itemCache[itemId];
  }

  checkRateLimit();

  // ‚úÖ Skip invalid or null item IDs
  if (!itemId || itemId === "N/A") {
    Logger.log("‚ö†Ô∏è Skipping item lookup: No valid item ID.");
    return { Name: "Unknown Item", Description: "No Description Available" };
  }

  // ‚úÖ Fetch from QuickBooks only if not in cache
  const accessToken = getAccessToken();
  if (!accessToken) {
    Logger.log("‚ùå No access token, cannot fetch item details.");
    return { Name: "Unknown Item", Description: "No Description Available" };
  }

  // üîÑ Removed SalesDesc since it causes an error
  const query = `SELECT Name, Description FROM Item WHERE Id = '${itemId}'`;
  const apiUrl = `${BASE_URL}${COMPANY_ID}/query?query=${encodeURIComponent(query)}`;

  const headers = {
    "Authorization": `Bearer ${accessToken}`,
    "Accept": "application/json"
  };

  const options = {
    method: "get",
    headers: headers,
    muteHttpExceptions: true
  };

  const response = fetchWithRetry(apiUrl, options);
  const json = JSON.parse(response.getContentText());

  // ‚úÖ Cache and return item details if found
  if (json.QueryResponse && json.QueryResponse.Item && json.QueryResponse.Item.length > 0) {
    const item = json.QueryResponse.Item[0];
    const itemDetails = {
      Name: item.Name,
      Description: item.Description || item.Name // Prefer Description ‚Üí Name
    };
    itemCache[itemId] = itemDetails;  // ‚úÖ Store in cache
    Logger.log(`‚úÖ Item Details Cached: ${JSON.stringify(itemDetails)}`);
    return itemDetails;
  } else {
    Logger.log(`‚ùå Item ID not found or missing description in QuickBooks: ${itemId}`);
    return { Name: "Unknown Item", Description: "No Description Available" };
  }
}



function getCustomerIdByName(customerName) {
  if (!customerName) {
    Logger.log("‚ùå No customer name provided.");
    return null;
  }

  // ‚úÖ Use cached data if available
  if (customerCache[customerId]) {
    return customerCache[customerId].email;
  }

  const accessToken = getAccessToken();
  if (!accessToken) {
    Logger.log("‚ùå No access token, cannot fetch customer.");
    return null;
  }

const query = "SELECT Id, DisplayName FROM Customer WHERE DisplayName = '" + customerName + "'";
  const apiUrl = BASE_URL + COMPANY_ID + "/query?query=" + encodeURIComponent(query);

  const headers = {
    "Authorization": "Bearer " + accessToken,
    "Accept": "application/json"
  };

  const options = {
    method: "get",
    headers: headers,
    muteHttpExceptions: true
  };

  const response = fetchWithRetry(apiUrl, options);
  const json = JSON.parse(response.getContentText());

  if (json.Customer && json.Customer.PrimaryEmailAddr) {
    const email = json.Customer.PrimaryEmailAddr.Address;
    customerCache[customerId] = { email: email };  // ‚úÖ Cache the email
    Logger.log("‚úÖ Customer email found: " + email);
    return email;
  } else {
    Logger.log("‚ö†Ô∏è No email found for Customer ID: " + customerId);
    return null;
  }
}


function getItemRefByName(itemName) {
  checkRateLimit();

  const accessToken = getAccessToken();
  if (!accessToken) {
    Logger.log("‚ùå No access token, cannot fetch item.");
    return null;
  }

  const query = "SELECT Id, Name FROM Item WHERE Name = '" + itemName + "'";
  const apiUrl = BASE_URL + COMPANY_ID + "/query?query=" + encodeURIComponent(query);

  const headers = {
    "Authorization": "Bearer " + accessToken,
    "Accept": "application/json"
  };

  const options = {
    method: "get",
    headers: headers,
    muteHttpExceptions: true
  };

  const response = fetchWithRetry(apiUrl, options);
  const json = JSON.parse(response.getContentText());

  if (json.QueryResponse && json.QueryResponse.Item && json.QueryResponse.Item.length > 0) {
    Logger.log("‚úÖ Item found: " + JSON.stringify(json.QueryResponse.Item[0]));
    return {
      value: json.QueryResponse.Item[0].Id,
      name: json.QueryResponse.Item[0].Name
    };
  } else {
    Logger.log("‚ùå Item not found in QuickBooks: " + itemName);
    return null;
  }
}

var customerCache = {};  // ‚úÖ Store customer details in memory

function getCustomerEmailById(customerId) {
  checkRateLimit();

  if (!customerId) {
    Logger.log("‚ùå No customer ID provided.");
    return null;
  }

  // ‚úÖ Return from cache if available
  if (customerCache[customerId]) {
    return customerCache[customerId].email;
  }

  const accessToken = getAccessToken();
  if (!accessToken) {
    Logger.log("‚ùå No access token, cannot fetch customer email.");
    return null;
  }

  const apiUrl = BASE_URL + COMPANY_ID + "/customer/" + customerId;

  const headers = {
    "Authorization": "Bearer " + accessToken,
    "Accept": "application/json"
  };

  const options = {
    method: "get",
    headers: headers,
    muteHttpExceptions: true
  };

  const response = fetchWithRetry(apiUrl, options);
  const json = JSON.parse(response.getContentText());

  if (json.Customer && json.Customer.PrimaryEmailAddr) {
    const email = json.Customer.PrimaryEmailAddr.Address;
    customerCache[customerId] = { email: email };  // ‚úÖ Cache the email
    Logger.log("‚úÖ Customer email found: " + email);
    return email;
  } else {
    Logger.log("‚ö†Ô∏è No email found for Customer ID: " + customerId);
    return null;
  }
}



function updateInvoiceInQBO(invoiceData) {
  checkRateLimit();

  try {
    const accessToken = getAccessToken();
    if (!accessToken) {
      Logger.log("‚ùå No access token, cannot update invoice.");
      return;
    }

    // ‚úÖ Fetch existing invoice details to get SyncToken, Customer ID, and Email
    const existingInvoice = getInvoiceByDocNumber(invoiceData.DocNumber);
    if (!existingInvoice || !existingInvoice.Id || !existingInvoice.SyncToken) {
      Logger.log("‚ùå Could not retrieve invoice details for updating.");
      return;
    }

    // ‚úÖ Preserve critical fields (Customer ID, SyncToken, Email)
    invoiceData.Id = existingInvoice.Id;
    invoiceData.SyncToken = existingInvoice.SyncToken;
    invoiceData.CustomerRef = { "value": existingInvoice.CustomerRef.value }; // Ensure correct Customer ID

    // ‚úÖ Preserve BillEmail if it exists
    if (existingInvoice.BillEmail && existingInvoice.BillEmail.Address) {
      invoiceData.BillEmail = { "Address": existingInvoice.BillEmail.Address };
      Logger.log("üìß Preserved Email: " + existingInvoice.BillEmail.Address);
    } else {
      // ‚úÖ Fetch email from customer profile if missing
      const customerEmail = getCustomerEmailById(existingInvoice.CustomerRef.value);
      if (customerEmail) {
        invoiceData.BillEmail = { "Address": customerEmail };
        Logger.log("üìß Retrieved Customer Email: " + customerEmail);
      } else {
        Logger.log("‚ö†Ô∏è No email found, skipping BillEmail field.");
      }
    }

    // ‚úÖ Ensure line items have correct calculations
    invoiceData.Line.forEach((line) => {
      if (line.SalesItemLineDetail) {
        var unitPrice = parseFloat(line.SalesItemLineDetail.UnitPrice);
        var qty = parseFloat(line.SalesItemLineDetail.Qty);

        // ‚úÖ Ensure Amount is correctly calculated to avoid QuickBooks 6070 Error
        line.Amount = parseFloat((unitPrice * qty).toFixed(2));

        // ‚úÖ Ensure Tax Code is set
        line.SalesItemLineDetail.TaxCodeRef = { "value": "NON" };
      }
    });

    const apiUrl = BASE_URL + COMPANY_ID + "/invoice";

    const headers = {
      "Authorization": "Bearer " + accessToken,
      "Accept": "application/json",
      "Content-Type": "application/json"
    };

    const payload = JSON.stringify(invoiceData);
    Logger.log("üì§ Sending Invoice Update (UPDATE): " + payload);

    const options = {
      method: "post",
      headers: headers,
      muteHttpExceptions: true,
      payload: payload
    };

    let response = fetchWithRetry(apiUrl, options);
    let responseJson = JSON.parse(response.getContentText());

    if (response.getResponseCode() === 200) {
      Logger.log("‚úÖ QuickBooks API Update Successful!");
      return;
    } 
    
    // ‚úÖ Handle API Errors
    else if (responseJson.Fault && responseJson.Fault.Error) {
      let errorCode = responseJson.Fault.Error[0].code;

      // ‚úÖ Ensure retryCount is properly initialized
      if (typeof invoiceData.retryCount === "undefined") {
        invoiceData.retryCount = 0; // Initialize retry count only once
      }

if (errorCode === "5010" && invoiceData.retryCount < 3) { // üõë Stale Object Error
    Logger.log("‚ö†Ô∏è Stale Object Error Detected! Fetching latest SyncToken...");

    const syncTokens = getAllSyncTokens([invoiceData.Id]); // Fetch in batch
    let latestSyncToken = syncTokens[invoiceData.Id];

    if (!latestSyncToken) {
        Logger.log("‚ùå Failed to fetch the latest SyncToken. Update aborted.");
        return;
    }

    invoiceData.SyncToken = latestSyncToken;
    invoiceData.retryCount++; // Increment retry count
    Logger.log(`üîÑ Retrying update (Attempt ${invoiceData.retryCount}) with new SyncToken: ${latestSyncToken}`);

    return updateInvoiceInQBO(invoiceData); // Retry with new token
} else if (invoiceData.retryCount >= 3) {
    Logger.log("‚ùå Max retries reached for Stale Object Error. Update aborted.");
    return; // üî¥ Prevents further execution after max retries
}

// üöÄ **Remove retryCount before sending to QuickBooks**
delete invoiceData.retryCount;

// ‚úÖ Proceed with the final API request
const response = fetchWithRetry(apiUrl, options);
Logger.log("‚úÖ QuickBooks API Response: " + response.getContentText());

if (response && response.getResponseCode() !== 200) { 
    let responseJson = JSON.parse(response.getContentText());
    if (responseJson.Fault) {
        Logger.log("‚ùå API Error: " + JSON.stringify(responseJson.Fault));
    }
}


    }
  } catch (error) {
    Logger.log("‚ùå Error in updateInvoiceInQBO: " + error.message);
  }
}

/**
 * üöÄ Pushes the invoice data from Google Sheets to QuickBooks.
 * @param {GoogleAppsScript.Spreadsheet.Sheet} sheet - The sheet containing invoice data.
 */
function pushInvoiceToQBO(sheet) {
  checkRateLimit();  // üõ° Prevent hitting API rate limits

  try {
    Logger.log("üìå Starting invoice sync for sheet: " + sheet.getName());

    // ‚úÖ Extract invoice details from the sheet
    var invoiceNumber = sheet.getRange("A1").getValue().replace("Invoice Number: ", "").trim();
    var txnDate = sheet.getRange("A2").getValue().replace("Date: ", "").trim();
    var customer = sheet.getRange("A3").getValue().replace("Customer: ", "").trim();
    var total = parseFloat(sheet.getRange("A4").getValue().replace("Total: $", "").trim());

    Logger.log("üìÜ Transaction Date: " + txnDate);
    Logger.log("üë§ Customer Name: " + customer);
    Logger.log("üí∞ Invoice Total: " + total);

    // ‚úÖ Check if the invoice already exists in QuickBooks
    var invoiceId = getInvoiceIdByDocNumber(invoiceNumber);
    if (!invoiceId) {
      Logger.log("‚ùå Invoice not found. Creating a new invoice.");
      createInvoiceInQBO(sheet);
      return;
    }

    // ‚úÖ Fetch SyncToken for the existing invoice
    var syncTokens = getAllSyncTokens([invoiceId]);
    var syncToken = syncTokens[invoiceId] || "0";  // Use default "0" if missing

    // ‚úÖ Prepare the invoice data for update
    var invoiceData = {
      "Id": invoiceId,
      "SyncToken": syncToken,
      "DocNumber": invoiceNumber,
      "TxnDate": txnDate,
      "CustomerRef": { "name": customer },
      "TotalAmt": 0,  // Will be calculated dynamically
      "Line": []
    };

    Logger.log("üîÑ Collecting line items for invoice...");

    // ‚úÖ Read line items from the sheet
    var lastRow = sheet.getLastRow();
    var calculatedTotal = 0;

    for (var row = 7; row <= lastRow; row++) {
      var itemName = sheet.getRange("A" + row).getValue().trim();
      var qty = parseFloat(sheet.getRange("B" + row).getValue());
      var rate = parseFloat(sheet.getRange("C" + row).getValue());
      var amount = parseFloat(sheet.getRange("D" + row).getValue());
      var itemRef = sheet.getRange("E" + row).getValue();

      // ‚úÖ Add line item if all fields are valid
      if (itemName && qty && rate && amount && itemRef) {
        Logger.log(`üõí Item: ${itemName} | Qty: ${qty} | Rate: ${rate} | Amount: ${amount} | ItemRef: ${itemRef}`);

        invoiceData.Line.push({
          "DetailType": "SalesItemLineDetail",
          "Amount": amount,
          "Description": itemName,  // Initially set to the sheet-provided name
          "SalesItemLineDetail": {
            "ItemRef": { "value": String(itemRef) },
            "Qty": qty,
            "UnitPrice": rate,
            "TaxCodeRef": { "value": "NON" }
          }
        });

        calculatedTotal += amount;
      }
    }

    // ‚úÖ Update the invoice total based on actual calculations
    invoiceData.TotalAmt = calculatedTotal;

    // ‚úÖ Overwrite descriptions with the correct Sales Description from QuickBooks
    invoiceData.Line.forEach((line) => {
      if (line.SalesItemLineDetail) {
        var itemId = line.SalesItemLineDetail.ItemRef.value;
        var itemDetails = getItemDetailsById(itemId); // Fetch item details from QuickBooks

        if (itemDetails && itemDetails.Description) {
          Logger.log(`üîÑ Overwriting Description: ${line.Description} ‚Üí ${itemDetails.Description}`);
          line.Description = itemDetails.Description;  // Use the actual Sales Description
        }
      }
    });

    Logger.log("üí∞ Final Calculated Total: " + invoiceData.TotalAmt);
    Logger.log("üì§ Sending Invoice Update (UPDATE): " + JSON.stringify(invoiceData));

    // ‚úÖ Push the updated invoice to QuickBooks
    updateInvoiceInQBO(invoiceData);

  } catch (error) {
    Logger.log("‚ùå Error in pushInvoiceToQBO: " + error.message);
  }
}




function fetchWithRetry(url, options, maxRetries = 3) {
  let attempts = 0;
  let delay = 2000; // Start with 2 seconds

  while (attempts < maxRetries) {
    try {
      const response = UrlFetchApp.fetch(url, options);
      const statusCode = response.getResponseCode();
      
      // ‚úÖ Capture intuit_tid from headers
      const intuitTid = response.getHeaders()['intuit_tid'] || 'N/A';
      Logger.log(`üÜî Intuit Transaction ID: ${intuitTid}`);

      if (statusCode === 200) {
        return response;  // ‚úÖ Success, return response
      } else if (statusCode === 429 || (statusCode >= 500 && statusCode < 600)) {
        // Handle 429 (Rate Limit) and 500-599 (Server Errors)
        Logger.log(`‚ö†Ô∏è API Limit or Server Error (${statusCode}). Retrying in ${delay / 1000} seconds...`);
        Utilities.sleep(delay);
        delay *= 2; // Exponential backoff
      } else {
        Logger.log(`‚ùå API request failed with status: ${statusCode} | Intuit TID: ${intuitTid}`);
        return response;  // Return response for further analysis
      }
    } catch (error) {
      Logger.log(`‚ùå Network Error: ${error.message}`);
      attempts++;
      if (attempts >= maxRetries) {
        Logger.log("‚ùå Max retries reached. Returning null.");
        return null;  // All retries failed
      }
      Logger.log(`üîÑ Retrying after ${delay / 1000} seconds (Attempt ${attempts}/${maxRetries})...`);
      Utilities.sleep(delay);
      delay *= 2;
    }
  }

  Logger.log("‚ùå Max retry limit reached for API request.");
  return null;
}



function onEditTrigger(e) {
  var uniqueRunId = new Date().getTime(); // Unique timestamp for each execution
  Logger.log(`üîÑ New Execution ID: ${uniqueRunId}`);

  var lock = LockService.getScriptLock();
  if (!lock.tryLock(500)) {
    Logger.log(`‚õî Execution ID ${uniqueRunId} skipped due to active lock.`);
    return; // üî• If another instance is running, exit immediately
  }

  try {
    var sheet = e.source.getActiveSheet();
    var range = e.range;
    Logger.log(`üîÑ Execution ID ${uniqueRunId}: Triggered onEditTrigger for range: ${range.getA1Notation()} in sheet: ${sheet.getName()}`);

    // ‚úÖ Handle "Menu" sheet checkboxes
    if (sheet.getName() === "Menu" && (range.getA1Notation() === "A2" || range.getA1Notation() === "A3")) {
      var check1 = sheet.getRange("A2").getValue();
      var check2 = sheet.getRange("A3").getValue();
      if (check1 && check2) {
        Logger.log(`‚úÖ Execution ID ${uniqueRunId}: Both checkboxes checked in 'Menu'! Refreshing Invoices...`);
        refreshInvoices();
        sheet.getRange("A2").setValue(false);
        sheet.getRange("A3").setValue(false);
      }
    }
// ‚úÖ Handle "Delete All" checkboxes
if (sheet.getName() === "Menu" && (range.getA1Notation() === "B2" || range.getA1Notation() === "B3")) {
  const checkB2 = sheet.getRange("B2").getValue();
  const checkB3 = sheet.getRange("B3").getValue();
  if (checkB2 && checkB3) {
    Logger.log(`üóë Execution ID ${uniqueRunId}: Both checkboxes checked in 'Menu'! Deleting all invoices...`);
    deleteAllInvoices();
    sheet.getRange("B2").setValue(false);
    sheet.getRange("B3").setValue(false);
  }
}



    // ‚úÖ Handle invoice sync checkboxes in invoice sheets
    if (range.getA1Notation() === "D2" || range.getA1Notation() === "D3") {
      var checkD2 = sheet.getRange("D2").getValue();
      var checkD3 = sheet.getRange("D3").getValue();
      if (checkD2 && checkD3) {
        var invoiceNumber = sheet.getRange("A1").getValue().replace("Invoice Number: ", "").trim();
        if (invoiceNumber) {
          Logger.log(`‚úÖ Execution ID ${uniqueRunId}: Both checkboxes checked! Syncing Invoice: ${invoiceNumber}`);
          pushInvoiceToQBO(sheet);
          sheet.getRange("D2").setValue(false);
          sheet.getRange("D3").setValue(false);
        } else {
          Logger.log(`‚ùå Execution ID ${uniqueRunId}: No invoice number found in A1.`);
        }
      }
    }

    // ‚úÖ Handle Google Chat invoice push when E2 and E3 are checked
    if (sheet.getName().startsWith("Inv_") && (range.getA1Notation() === "E2" || range.getA1Notation() === "E3")) {
      var checkE2 = sheet.getRange("E2").getValue();
      var checkE3 = sheet.getRange("E3").getValue();
      if (checkE2 && checkE3) {
        var invoiceNumber = sheet.getRange("A1").getValue().replace("Invoice Number: ", "").trim();
        if (invoiceNumber) {
          Logger.log(`üì© Execution ID ${uniqueRunId}: Sending Invoice ${invoiceNumber} to Google Chat.`);
          // ‚úÖ Pass the full invoice data to sendInvoiceToRequester
          sendInvoiceToRequester(sheet, {
            DocNumber: invoiceNumber,
            CustomerRef: { name: sheet.getRange("A3").getValue().replace("Customer: ", "").trim() },
            TotalAmt: parseFloat(sheet.getRange("A4").getValue().replace("Total: $", "").trim()),
            Id: invoiceNumber // Assuming DocNumber matches the Invoice ID
          });
          sheet.getRange("E2").setValue(false);
          sheet.getRange("E3").setValue(false);
        } else {
          Logger.log(`‚ùå Execution ID ${uniqueRunId}: No invoice number found for Google Chat push.`);
        }
      }
    }

  } catch (error) {
    Logger.log(`‚ùå Execution ID ${uniqueRunId}: Error in onEditTrigger: ${error.message}`);
  } finally {
    lock.releaseLock(); // üîì Ensure lock is always released
    Logger.log(`üîì Execution ID ${uniqueRunId} released lock.`);
  }
}


function createInstallableTrigger() {
  var triggers = ScriptApp.getProjectTriggers();
  
  // Avoid duplicate triggers
  for (var i = 0; i < triggers.length; i++) {
    if (triggers[i].getHandlerFunction() === "onEditTrigger") {
      Logger.log("üöÄ Installable trigger already exists!");
      return;
    }
  }
  
  ScriptApp.newTrigger("onEditTrigger")
    .forSpreadsheet(SpreadsheetApp.openById('17V9u1Bz0LM0xOPz3AayXcRh4xIvYnRamfb2x3f9O7Z8'))
    .onEdit()
    .create();
  
  Logger.log("‚úÖ Installable trigger created!");
}


/**
 * ‚úÖ Run this function once to set up the trigger!
 */
function setup() {
  createInstallableTrigger();
}



function encryptData(plainText) {
    return encryptWithKMS(plainText);
}

function decryptData(cipherText) {
    return decryptWithKMS(cipherText);
}


function testEncryption() {
    var passphrase = '0nofFCM8RE4KrUKSHG-oTiOcoOItxm1Fao1GWhLV-2s';
    var originalText = 'Sensitive data to encrypt';

    // Encrypt the data
    var encryptedText = encryptData(originalText, passphrase);
    Logger.log('Encrypted Text: ' + encryptedText);

    // Decrypt the data
    var decryptedText = decryptData(encryptedText, passphrase);
    Logger.log('Decrypted Text: ' + decryptedText);
}


function storeClientCredentialsSecurely() {
  const clientId = "YOUR_CLIENT_ID";
  const clientSecret = "ENCRYPTED_CLIENT_SECRET";
  
  PropertiesService.getScriptProperties().setProperty("ENCRYPTED_CLIENT_ID", encryptWithKMS(clientId));
  PropertiesService.getScriptProperties().setProperty("ENCRYPTED_CLIENT_SECRET", encryptWithKMS(clientSecret));
  
  Logger.log("üîí Client credentials securely stored using KMS.");
}




function authorize() {
  var service = getOAuthService();
  if (!service.hasAccess()) {
    var authorizationUrl = service.getAuthorizationUrl();
    Logger.log('üìå Open the following URL to authorize the app: ' + authorizationUrl);
  } else {
    Logger.log('‚úÖ App already authorized.');
  }
}


function clearOAuthTokens() {
  var service = getOAuthService();
  service.reset();
  Logger.log("üîÑ Cleared stored OAuth tokens.");
}



function verifyAuthorization() {
  var service = getOAuthService();
  if (service.hasAccess()) {
    Logger.log("‚úÖ Successfully authorized and access token stored for all users.");
  } else {
    Logger.log("‚ùå Authorization failed. Please run 'authorize()' as the admin.");
  }
}



function createTriggers() {
  const ss = SpreadsheetApp.openById('17V9u1Bz0LM0xOPz3AayXcRh4xIvYnRamfb2x3f9O7Z8');
  
  ScriptApp.newTrigger('onEditTrigger')
    .forSpreadsheet(ss)
    .onEdit()
    .create();
}




function sendInvoiceToRequester(sheet, invoiceData) {
  const selectedName = sheet.getRange("F2").getValue();

  const userWebhooks = {
    "Alex": "https://chat.googleapis.com/v1/spaces/AAAAWPBf07k/messages?key=AIzaSyDdI0hCZtE6vySjMm-WEfRq3CPzqKqqsHI&token=YxJbKPAinj6wuEUBkXrGDmxZ_7-o6eHMTTlMFnnMVK4",
    "Ceci": "https://chat.googleapis.com/v1/spaces/AAAAWPBf07k/messages?key=AIzaSyDdI0hCZtE6vySjMm-WEfRq3CPzqKqqsHI&token=YxJbKPAinj6wuEUBkXrGDmxZ_7-o6eHMTTlMFnnMVK4",
    "TABLET 1": "https://chat.googleapis.com/v1/spaces/AAAAA299z9Q/messages?key=AIzaSyDdI0hCZtE6vySjMm-WEfRq3CPzqKqqsHI&token=4mhuoOJ6IUuR9b5C6A0ENCJrC-l-INKWXLvkqhoPv0c",
  };

  if (!userWebhooks[selectedName]) {
    Logger.log(`‚ùå No Google Chat webhook defined for user: ${selectedName}`);
    return;
  }

  const webhookUrl = userWebhooks[selectedName];
  const invoiceId = getInvoiceIdByDocNumber(invoiceData.DocNumber);

  if (!invoiceId) {
    Logger.log(`‚ùå No invoice ID found for DocNumber: ${invoiceData.DocNumber}`);
    return;
  }

  const pdfBlob = fetchInvoicePDF(invoiceId);
  if (!pdfBlob) {
    Logger.log("‚ùå PDF not available for this invoice.");
    return;
  }

  // Upload the PDF temporarily to Drive
  const file = DriveApp.createFile(pdfBlob);
  file.setName(`Invoice_${invoiceData.DocNumber}.pdf`);
  file.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW);

  const pdfLink = file.getUrl();

  // Prepare the message with the temporary link
  const message = {
    text: `üßæ *Invoice Synced Successfully!*\n\nInvoice Number: ${invoiceData.DocNumber}\nCustomer: ${invoiceData.CustomerRef.name}\nTotal: $${invoiceData.TotalAmt}\n\nüìé [Download Invoice PDF](${pdfLink})\n\nüïí Link will expire in 2 minutes.`
  };

  // Send the invoice link to Google Chat
  const options = {
    method: 'post',
    contentType: 'application/json',
    payload: JSON.stringify(message)
  };

  try {
    UrlFetchApp.fetch(webhookUrl, options);
    Logger.log(`‚úÖ Invoice sent successfully to ${selectedName}`);

    // Schedule deletion after 2 minutes
    deleteFileAfterDelay(file.getId(), 2);
  } catch (error) {
    Logger.log(`‚ùå Failed to send invoice to ${selectedName}: ${error.message}`);
  }
}

// ‚è≥ Deletes the file after a delay (in minutes)
function deleteFileAfterDelay(fileId, delayMinutes) {
  ScriptApp.newTrigger('deleteTempInvoicePDF')
    .timeBased()
    .after(delayMinutes * 60 * 1000) // Convert minutes to milliseconds
    .create();

  // Store the file ID for deletion
  PropertiesService.getScriptProperties().setProperty('TEMP_INVOICE_FILE_ID', fileId);
}

// üóëÔ∏è Deletes the temporary invoice PDF
function deleteTempInvoicePDF() {
  const fileId = PropertiesService.getScriptProperties().getProperty('TEMP_INVOICE_FILE_ID');

  if (fileId) {
    try {
      const file = DriveApp.getFileById(fileId);
      file.setTrashed(true);
      Logger.log(`üóëÔ∏è Temporary invoice PDF deleted: ${fileId}`);
    } catch (error) {
      Logger.log(`‚ùå Error deleting file: ${error.message}`);
    }

    // Clear the stored file ID
    PropertiesService.getScriptProperties().deleteProperty('TEMP_INVOICE_FILE_ID');
  }
}

function getCurrentUserEmail() {
  const email = Session.getEffectiveUser().getEmail();
  Logger.log(`üìß Detected User Email: ${email}`);
  return email;
}




function fetchInvoicePDF(invoiceId) {
  const accessToken = getAccessToken();
  const apiUrl = `${BASE_URL}${COMPANY_ID}/invoice/${invoiceId}/pdf`;

  const options = {
    method: "get",
    headers: {
      "Authorization": `Bearer ${accessToken}`,
      "Accept": "application/pdf"
    },
    muteHttpExceptions: true
  };

  const response = UrlFetchApp.fetch(apiUrl, options);
  const statusCode = response.getResponseCode();

  if (statusCode === 200) {
    const pdfBlob = response.getBlob();
    saveInvoicePDFTemporarily(invoiceId, pdfBlob); // Save and set auto-delete
    return pdfBlob;
  } else {
    Logger.log("‚ùå Failed to fetch invoice PDF: " + response.getContentText());
    return null;
  }
}



function saveInvoicePDFTemporarily(invoiceId, pdfBlob) {
  const folder = DriveApp.getFolderById("1IzDXm3Uu-Aa5UyIaKhRcX13x_tbhO1HK"); // Replace with your actual folder ID
  const fileName = `Temp_Invoice_${invoiceId}_${new Date().getTime()}.pdf`;

  // Save PDF to Drive
  const file = folder.createFile(pdfBlob).setName(fileName);
  Logger.log(`‚úÖ PDF saved temporarily: ${fileName}`);

  // Store the file ID in an array
  const properties = PropertiesService.getScriptProperties();
  let fileIds = properties.getProperty("TEMP_INVOICE_IDS");
  fileIds = fileIds ? JSON.parse(fileIds) : [];
  fileIds.push(file.getId());
  properties.setProperty("TEMP_INVOICE_IDS", JSON.stringify(fileIds));

  // Set an individual trigger to delete after 2 minutes
  ScriptApp.newTrigger("deleteSpecificTempInvoicePDF")
    .timeBased()
    .after(2 * 60 * 1000) // 2 minutes
    .create();

  return file.getId();
}

function deleteSpecificTempInvoicePDF() {
  const lock = LockService.getScriptLock();
  if (!lock.tryLock(500)) {
    Logger.log("‚è≥ Another deletion process is running. Skipping this run.");
    return;
  }

  try {
    const properties = PropertiesService.getScriptProperties();
    let fileIds = properties.getProperty("TEMP_INVOICE_IDS");

    if (fileIds) {
      fileIds = JSON.parse(fileIds);

      if (fileIds.length > 0) {
        const fileIdToDelete = fileIds.shift(); // Remove the oldest file ID

        try {
          const file = DriveApp.getFileById(fileIdToDelete);

          if (file.isTrashed()) {
            Logger.log(`‚ö†Ô∏è File ${fileIdToDelete} already trashed.`);
          } else {
            file.setTrashed(true);
            Logger.log(`üóëÔ∏è Temp invoice PDF deleted: ${fileIdToDelete}`);
          }

        } catch (error) {
          Logger.log(`‚ùå Error deleting PDF (may not exist): ${error.message}`);
        }

        // Update the stored list of file IDs
        properties.setProperty("TEMP_INVOICE_IDS", JSON.stringify(fileIds));

        // üîÑ Schedule the next deletion if files remain
        if (fileIds.length > 0) {
          scheduleNextFileDeletion();
        }

      } else {
        Logger.log("‚ö†Ô∏è No files to delete.");
      }
    } else {
      Logger.log("‚ö†Ô∏è No file list found in properties.");
    }
  } finally {
    lock.releaseLock();
  }
}

// ‚è≥ Automatically schedules the next deletion after 2 minutes
function scheduleNextFileDeletion() {
  ScriptApp.newTrigger('deleteSpecificTempInvoicePDF')
    .timeBased()
    .after(2 * 60 * 1000) // 2 minutes delay
    .create();

  Logger.log("üïí Scheduled the next deletion in 2 minutes.");
}

function fetchAndSyncAllItemsToAllItemsSheet() {
  checkRateLimit();

  const accessToken = getAccessToken();
  if (!accessToken) {
    Logger.log("‚ùå No access token for fetching items.");
    return;
  }

  const ss = SpreadsheetApp.openById('17V9u1Bz0LM0xOPz3AayXcRh4xIvYnRamfb2x3f9O7Z8'); // Replace with your sheet ID
  let sheet = ss.getSheetByName("ALL ITEMS");

  // ‚úÖ Create or clear the ALL ITEMS sheet
  if (!sheet) {
    sheet = ss.insertSheet("ALL ITEMS");
  } else {
    sheet.clear(); // Clear all previous data
  }

  // ‚úÖ Set headers
  const headers = ["Item ID", "Item Name", "SKU", "Description", "Unit Price", "Active"];
  sheet.getRange(1, 1, 1, headers.length).setValues([headers]);

  // ‚úÖ Fetch all items
  let allItems = [];
  let startPosition = 1;
  let hasMore = true;

  while (hasMore) {
    const query = `SELECT Id, Name, Sku, Description, UnitPrice, Active FROM Item STARTPOSITION ${startPosition} MAXRESULTS 1000`;
    const apiUrl = `${BASE_URL}${COMPANY_ID}/query?query=${encodeURIComponent(query)}`;

    const options = {
      method: "get",
      headers: {
        "Authorization": `Bearer ${accessToken}`,
        "Accept": "application/json"
      },
      muteHttpExceptions: true
    };

    const response = UrlFetchApp.fetch(apiUrl, options);
    const json = JSON.parse(response.getContentText());

    if (json.QueryResponse && json.QueryResponse.Item) {
      json.QueryResponse.Item.forEach(item => {
        allItems.push([
          item.Id || "N/A",
          item.Name || "Unnamed Item",
          item.Sku || "N/A",
          item.Description || "No Description",
          item.UnitPrice || 0,
          item.Active ? "Yes" : "No"
        ]);
      });

      if (json.QueryResponse.startPosition + json.QueryResponse.maxResults > json.QueryResponse.totalCount) {
        hasMore = false;
      } else {
        startPosition += 1000;
      }
    } else {
      hasMore = false;
    }
  }

  // ‚úÖ Insert items into the sheet
  if (allItems.length > 0) {
    sheet.getRange(2, 1, allItems.length, headers.length).setValues(allItems);
    Logger.log(`‚úÖ Successfully synced ${allItems.length} items from QuickBooks.`);
  } else {
    Logger.log("‚ö†Ô∏è No items found in QuickBooks.");
  }

  // ‚úÖ Lock the entire sheet for everyone except management
  lockAllItemsSheet(sheet);

  Logger.log("üîí ALL ITEMS tab locked. Only management can edit.");
}

// üîí Lock the ALL ITEMS sheet for everyone except management
function lockAllItemsSheet(sheet) {
  const managementEmails = [

  ]; // Management emails

  const protection = sheet.protect().setDescription("ALL ITEMS Lock");
  protection.addEditors(managementEmails);

  // Remove all other editors
  const allEditors = protection.getEditors();
  allEditors.forEach(editor => {
    if (!managementEmails.includes(editor.getEmail())) {
      protection.removeEditor(editor);
    }
  });

  // Prevent domain-wide editing
  if (protection.canDomainEdit()) {
    protection.setDomainEdit(false);
  }
}



function clearItemCache() {
  itemCache = {};  // Clears the cached item details
  Logger.log("üßπ Item cache cleared successfully.");
}

function clearAndReauthorize() {
  clearOAuthTokens();  // Clear existing tokens
  authorize();         // Prompt reauthorization
}
